/** B+ tree implementation of the link template for linearizable dictionaries. */

options "-simplearrays -symbexec -propreads"

include "../include/flows.spl"
include "array_util.spl"


/** Flow and node domain definitions */

datatype FlowDom = fd(ks: Map<K, Int>, ir: Map<K, Int>)

pure predicate domEq(p1: FlowDom, p2: FlowDom) {
  (forall k: K :: p1.ks[k] == p2.ks[k]
   @(matching p1.ks[k] yields p2.ks[k]) @(matching p2.ks[k] yields p1.ks[k]))
    && (forall k: K :: p1.ir[k] == p2.ir[k]
       @(matching p1.ir[k] yields p2.ir[k]) @(matching p2.ir[k] yields p1.ir[k]))

}

pure predicate domLeq(p1: FlowDom, p2: FlowDom) {
  (forall k: K :: p1.ks[k] <= p2.ks[k]
   @(matching p1.ks[k] yields p2.ks[k]) @(matching p2.ks[k] yields p1.ks[k]))
    && (forall k: K :: p1.ir[k] <= p2.ir[k]
       @(matching p1.ir[k] yields p2.ir[k]) @(matching p2.ir[k] yields p1.ir[k]))
}

pure function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
  ensures forall k: K :: p.ks[k] == p1.ks[k] + p2.ks[k]
  ensures forall k: K :: p.ir[k] == p1.ir[k] + p2.ir[k]

pure function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
  ensures forall k: K :: p.ks[k] == p1.ks[k] * p2.ks[k]
  ensures forall k: K :: p.ir[k] == p1.ir[k] * p2.ir[k]

pure function domZero() returns(p: FlowDom)
  ensures forall k: K :: p.ks[k] == 0 && p.ir[k] == 0


datatype InrFn = inrfnC(inrfn: Map<Node, Set<K>>, inrdom: Set<Node>) | inrfnUndef;
  
datatype NodeDom = nd(contents: Set<K>, inr: InrFn);

pure predicate ndLeq(a1: NodeDom, a2: NodeDom) {
  (forall k: K :: k in a1.contents ==> k in a2.contents)
    && (a2.inr == inrfnUndef || a1.inr != inrfnUndef && a2.inr != inrfnUndef
       && (forall x: Node :: x in a1.inr.inrdom ==> x in a2.inr.inrdom && a1.inr.inrfn[x] == a2.inr.inrfn[x]))
}


/** Definition of a node */

struct Node {
  var locktid: Int;
  var len: Int;
  var keys: Array<K>;
  var ptrs: Array<Node>;
  var next: Node;
}

define unchanged(x) {
  x.locktid == old(x.locktid) && x.len == old(x.len) && x.next == old(x.next)
    && x.keys == old(x.keys) && x.ptrs == old(x.ptrs)
    && x.keys.length == old(x.keys.length) && x.keys.map == old(x.keys.map)
    && x.ptrs.length == old(x.ptrs.length) && x.ptrs.map == old(x.ptrs.map)
}


/** Definition of heap representation, hrep */

var B: Int
axiom B > 1

define hrepSpatial(x) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs)
}

define hrep(x, I) {
  hrepSpatial(x) &*& I.FP == {x} &*& x.next != x
    && 0 <= x.len && x.len < 2*B && x.keys.length == 2*B && x.ptrs.length == 2*B
    // Keys are sorted
    && (forall i: Int, j: Int :: 0 <= i < j <= x.len ==> lt(x.keys[i], x.keys[j]))
    && (x.ptrs[0] == null  // Leaf
       && I.na.contents == set_of_map(x.keys.map, 0, x.len)
       && (x.next == null && I.FPo == {}
          || x.next != null && I.FPo == {x.next}
          && (forall k: K :: le(x.keys[x.len], k) ==> I.fm[x][x.next].ks[k] == 1)
          && (forall k: K :: lt(k, x.keys[x.len]) ==> I.fm[x][x.next].ks[k] == 0)
             )
     || x.ptrs[0] != null  // Internal
       && I.na.contents == {}
       && (forall i: Int :: 0 <= i <= x.len ==> x != x.ptrs[i])
       && (forall i: Int, j: Int :: 0 <= i < j <= x.len ==> x.ptrs[i] != x.ptrs[j])
       && (forall i: Int, k: K :: 0 <= i <= x.len ==> x.ptrs[i] != null && x.ptrs[i] in I.FPo)
       && (forall i: Int, k: K :: 0 <= i < x.len ==>
          (I.fm[x][x.ptrs[i]].ks[k] == 1
          && ((i <= 0 || le(x.keys[i-1], k)) && (i >= x.len || lt(k, x.keys[i])))
           || I.fm[x][x.ptrs[i]].ks[k] == 0
           && !((i <= 0 || le(x.keys[i-1], k)) && (i >= x.len || lt(k, x.keys[i]))))
          @(matching x.ptrs[i] yields I.fm[x][x.ptrs[i]].ks[k])
          @(matching x.keys[i] yields I.fm[x][x.ptrs[i]].ks[k]))
        && (x.next == null
            && (forall k: K :: 
               (I.fm[x][x.ptrs[x.len]].ks[k] == 1
               && (x.len <= 0 || le(x.keys[x.len-1], k))
               || I.fm[x][x.ptrs[x.len]].ks[k] == 0
               && !(x.len <= 0 || le(x.keys[x.len-1], k))))
               && x.next !in I.FPo
            || x.next != null
              && (forall k: K :: 
                 (I.fm[x][x.ptrs[x.len]].ks[k] == 1
                 && (x.len <= 0 || le(x.keys[x.len-1], k)) && lt(k, x.keys[x.len])
                 || I.fm[x][x.ptrs[x.len]].ks[k] == 0
                  && !((x.len <= 0 || le(x.keys[x.len-1], k)) && lt(k, x.keys[x.len]))))
              && (forall k: K ::
                   I.fm[x][x.next].ks[k] == 1 && le(x.keys[x.len], k)
                 || I.fm[x][x.next].ks[k] == 0 && lt(k, x.keys[x.len])
                 )
            )
      )
}
/* TODO have a create B+ tree function to check this isn't unsat */

/*
procedure aaa_test(x: Node, c0: Node, c1: Node, n: Node, I: Interface)
  requires x != c0 && x != c1 && x != n && c0 != c1 && c0 != n && c1 != n
  requires x != null && c0 != null && c1 != null && n != null
  requires x.len == 1 && x.ptrs.length == 4 && x.keys.length == 4 && B == 2
  requires x.next == n && x.ptrs[0] == c0 && x.ptrs[1] == c1
  requires x.keys[0] == 1 && x.keys[1] == 5
  requires acc(x) &*& acc(x.keys) &*& acc(x.ptrs)
  requires I.FP == {x} && I.FPo == {c0, c1, n} && I.na.contents == {}
  requires forall n: Node, n1: Node, k: K :: n != x ==> I.fm[n][n1].ks[k] == 0
  requires forall n: Node, k: K :: n !in I.FPo ==> I.fm[x][n].ks[k] == 0
  requires forall n: Node, k: K :: n in {c0} && k < 1 ==> I.fm[x][n].ks[k] == 1
  requires forall n: Node, k: K :: n in {c0} && k >= 1 ==> I.fm[x][n].ks[k] == 0
  @(matching n yields I.fm[x][n].ks[k])
  requires forall n: Node, k: K :: n in {c1} && 1 <= k < 5 ==> I.fm[x][n].ks[k] == 1
  requires forall n: Node, k: K :: n in {c1} && !(1 <= k < 5) ==> I.fm[x][n].ks[k] == 0
  requires forall y: Node, k: K :: y in {n} && 5 <= k ==> I.fm[x][y].ks[k] == 1
  requires forall y: Node, k: K :: y in {n} && !(5 <= k) ==> I.fm[x][y].ks[k] == 0
  ensures hrep(x, I)
{}
 */

// TODO update
lemma keyset_implies_leaf(x: Node, Ix: Interface, k: K, i: Int)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  requires (i <= 0 || le(x.keys[i-1], k)) && 0 <= i <= x.len
  ensures hrep(x, Ix) &*& unchanged(x)
  ensures x.ptrs[0] == null  // x is a leaf
/*{
  if (x.ptrs[0] != null) {
    if (i < x.len) {
      if (lt(k, x.keys[i])) {
        pure assert Ix.fm[x][x.ptrs[i]].ks[k] == 1;
      } else {
        keyset_implies_leaf(x, Ix, k, i + 1);
      }
    } else {
      pure assert Ix.fm[x][x.ptrs[i]].ks[k] == 1;
    }
  }
   }*/

/** Begin programs */

//var TID: Int
//axiom TID > 0
//var r: Node


/** findNext */
procedure findNext(x: Node, k: K, Ix: Interface)
  returns (n: Node)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  ensures hrep(x, Ix)
  ensures (n != null && Ix.fm[x][n].ks[k] >= 1
           || n == null && (forall y: Node :: Ix.fm[x][y].ks[k] == 0))
{
  if (x.ptrs[0] == null) {  // Leaf node
    if (x.next == null) {
      lemma_int_valid_unfold(Ix);
      return null;
    }
    if (le(x.keys[x.len], k)) {
      return x.next;
    } else {
      lemma_int_valid_unfold(Ix);
      return null;
    }
  }

  var found, i := arr_find(x.keys, x.len, k);

  if (i == 0 && k == x.keys[i]) {
    i := i + 1;
  }

  if (i == x.len && x.next != null) {
    if (lt(k, x.keys[i]))
      n := x.ptrs[i];
    else
      n := x.next;
  } else {
    n := x.ptrs[i];
  }
  // return n;
}


/** member */
procedure member(x: Node, k: K, Ix: Interface)
  returns (succ: Bool, res: Bool, Ix1: Interface)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures hrep(x, Ix)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (Ix1.na.contents == Ix.na.contents && (res == k in Ix.na.contents))
{
  keyset_implies_leaf(x, Ix, k, 0);

  var idx: Int;
  res, idx := arr_find(x.keys, x.len, k);

  return true, res, Ix;
}


/** insert */
procedure insert(x: Node, k: K, Ix: Interface)
  returns (succ: Bool, res: Bool, Ix1: Interface)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures hrep(x, Ix1)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (Ix1.na.contents == Ix.na.contents ++ {k} && (res == k !in Ix.na.contents))
{
  keyset_implies_leaf(x, Ix, k, 0);
  pure assume lt(k, x.keys[x.len]); // TODO Follows from k !in outset

  if (x.len < 2*B - 1) {

    ghost var m0 := x.keys.map;
    x.keys[x.len + 1] := x.keys[x.len];
    set_of_map_equal(m0, x.keys.map, 0, 0, x.len);
    ghost var m := x.keys.map; var old_len := x.len;
    var idx, new_len := arr_insert(x.keys, k, x.len);
    map_insert_content_set(m, x.keys.map, idx, k, x.len, new_len);
    x.len := new_len;

    // Define Ix1 to be Ix, but with k added to contents
    Ix1 := copy_interface(Ix, nd(Ix.na.contents ++ {k}, Ix.na.inr));
    lemma_int_valid_unfold(Ix);
    lemma_int_valid_fold(Ix1);

    if (k in Ix.na.contents)  // TODO why?
      return true, false, Ix1;
    else
      return true, true, Ix1;
  } else {
    return false, false, Ix;
  }
}


/** delete */
procedure delete(x: Node, k: K, Ix: Interface)
  returns (succ: Bool, res: Bool, Ix1: Interface)
  requires hrep(x, Ix) &*& intValid(Ix) == true
  requires Ix.inf[x].ks[k] == 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures hrep(x, Ix1)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures succ ==> (Ix1.na.contents == Ix.na.contents -- {k} && (res == k in Ix.na.contents))
{
  keyset_implies_leaf(x, Ix, k, 0);

  ghost var m := x.keys.map;

  var new_len, idx := arr_delete(x.keys, k, x.len);

  map_delete_content_set(m, x.keys.map, x.len, new_len, idx, k);

  ghost var m1 := x.keys.map;
  x.keys[new_len] := x.keys[x.len];
  set_of_map_equal(m1, x.keys.map, 0, 0, new_len);

  x.len := new_len;

  // Define Ix1 to be Ix, but with k removed from contents
  Ix1 := copy_interface(Ix, nd(Ix.na.contents -- {k}, Ix.na.inr));
  lemma_int_valid_unfold(Ix);
  lemma_int_valid_fold(Ix1);

  return true, (k in Ix.na.contents), Ix1;
}

