include "../include/flows.spl";

/** Flow domain definitions */

datatype FlowDom = pair(fst: Int, snd: Int);

datatype NodeDom = nd;

function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{ pair(p1.fst + p2.fst, p1.snd + p2.snd) }

function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{ pair(p1.fst * p2.fst, p1.snd * p2.snd) }

function domZero() returns(p: FlowDom) { pair(0, 0) }
  
predicate ndLeq(a1: NodeDom, a2: NodeDom)

struct Node {
  var next: Node;
  var data: Int;
}


/** Gamma is hardcoded into these two lemmas */

procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures [acc(x) &*& I.inf[x].fst == 1 &*& I.inf[x].snd < x.data &*& (x.next == null && I.FPo == {} || x.next != null && I.FPo == {x.next} && I.fm[x][x.next] == pair(1, x.data))](I) &*& I.FP == {x}

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires [acc(x) &*& I1.inf[x].fst == 1 &*& I1.inf[x].snd < x.data &*& (x.next == null && I1.FPo == {} || x.next != null && I1.FPo == {x.next} && I1.fm[x][x.next] == pair(1, x.data))](I) &*& I1.FP == {x}
  ensures [N(x, I1)](I)

/** Lemmas */

procedure no_op(x: Node, I: Interface)
  requires N(x, I) &*& intValid(I) == true
  ensures N(x, I)
{
  lemma_conc(x, I);
  var y := x.next;
  x.next := y;
  lemma_abs(x, I, I);
  lemma_int_leq_fold(I, I);
  sync(I, I);
}
