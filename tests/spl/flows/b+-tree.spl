/** B+ tree implementation of the give-up template for linearizable dictionaries. */

include "../include/flows.spl";


/** Flow domain definitions */

datatype FlowDom = fd(ks: Map<Int, Int>);

predicate domEq(p1: FlowDom, p2: FlowDom) {
  forall k: Int :: p1.ks[k] == p2.ks[k]
    @(matching p1.ks[k] yields p2.ks[k]) @(matching p2.ks[k] yields p1.ks[k])
}

predicate domLeq(p1: FlowDom, p2: FlowDom) {
  forall k: Int :: p1.ks[k] <= p2.ks[k]
}

function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
  ensures forall k: Int :: p.ks[k] == p1.ks[k] + p2.ks[k]

function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
  ensures forall k: Int :: p.ks[k] == p1.ks[k] * p2.ks[k]

function domZero() returns(p: FlowDom)
  ensures forall k: Int :: p.ks[k] == 0

datatype LockInfo = unlocked | locked(tid: Int) | dirtylock(dtid: Int);
// Need dirtylock because every intermediate state must imply Gr(I),
// but when node is locked all conditions of gamma need not hold
  
datatype NodeDom = nd(contents: Set<Int>, lockinfo: Set<LockInfo>);
// TODO can do with LockInfo instead of Set<LockInfo>?

predicate ndLeq(a1: NodeDom, a2: NodeDom) {
  (forall x: Int :: x in a1.contents ==> x in a2.contents)
    && (forall l: LockInfo :: l in a1.lockinfo ==> l in a2.lockinfo)
}


struct Node {
  var lock: Int;
  var len: Int;
  var rangeLb: Int;
  var rangeUb: Int;
  var keys: Array<Int>;
  var ptrs: Array<Node>;
}

define unchanged(x) {
  x.lock == old(x.lock) && x.len == old(x.len) && x.rangeLb == old(x.rangeLb)
    && x.rangeUb == old(x.rangeUb) && x.keys == old(x.keys) && x.ptrs == old(x.ptrs)
}

/** Definition of good condition, gamma */

function cont_witness(x: Node, Ix: Interface, k: Int)
  returns(idx: Int)

define gammaG(x, I) {
  0 <= x.len && x.len < x.keys.length && x.len < x.ptrs.length
    && (forall k: Int :: (I.inf[x].ks[k] >= 1) == (x.rangeLb <= k && k < x.rangeUb))
    && (forall i: Int, j: Int :: 0 <= i && i < j && j < x.len ==> x.keys[i] < x.keys[j])
    && (x.ptrs[0] == null && I.FPo == {}  // Leaf
       && (forall i: Int :: 0 <= i && i < x.ptrs.length ==> x.ptrs[i] == null)
       && (forall i: Int :: 0 <= i && i < x.len ==> x.keys[i] in I.na.contents)
       && (forall k: Int :: k in I.na.contents
          ==> (k == x.keys[cont_witness(x, I, k)]
             && 0 <= cont_witness(x, I, k) && cont_witness(x, I, k) < x.len)
          @(matching k without cont_witness yields x.keys[cont_witness(x, I, k)]))
       || x.ptrs[0] != null  // Internal
       && (forall i: Int, k: Int :: 0 <= i && i <= x.len ==>
          x.ptrs[i] != null && x.ptrs[i] in I.FPo
          && ((I.fm[x][x.ptrs[i]].ks[k] >= 1) ==
             ((i <= 0 || x.keys[i-1] <= k) && (i >= x.len || k < x.keys[i])))
          @(matching x.ptrs[i] yields x.keys[i-1])
          @(matching x.ptrs[i] yields x.keys[i])))
}

define gammaB(x, I) {
  0 <= x.len && x.len < x.keys.length && x.len < x.ptrs.length
}

define gamma(x, I) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs)
    &*& ((gammaG(x, I) && I.na.lockinfo == {locked(TID)}
         || gammaB(x, I) && I.na.lockinfo == {dirtylock(TID)})
/* TODO have a create B+ tree function to check this isn't unsat */
       && (forall k: Int :: k in I.na.contents ==> I.inf[x].ks[k] >= 1)
       && (forall k: Int, y: Node :: k !in I.na.contents || I.fm[x][y].ks[k] == 0)
       && (forall k: Int, y: Node, z: Node :: y == z || I.fm[x][y].ks[k] == 0 || I.fm[x][z].ks[k] == 0))
}


/** Lemmas to deal with conjunction */

// This follows from semantics of sync not modifying heap
procedure gamma_sync(x: Node, xlock: Int, xlen: Int, xrangeLb: Int, xrangeUb: Int, xkeys: Array<Int>, xptrs: Array<Node>, Ix: Interface, Ix1: Interface)
  returns ()
  requires [gamma(x, Ix1)](Ix) &*& intValid(Ix1) == true &*& intEq(Ix, Ix1) == true
  ensures [gamma(x, Ix1)](Ix1) &*& unchanged(x)

lemma lemma_gamma_comp_sing_int(x: Node, xlock: Int, xlen: Int, xrangeLb: Int, xrangeUb: Int, xkeys: Array<Int>, xptrs: Array<Node>, Ix: Interface, I2: Interface)
  returns (I: Interface)
  requires [gamma(x, Ix)](Ix) &*& Gr(I2)
  ensures [gamma(x, Ix)](Ix) &*& Gr(I2) &*& intComp(Ix, I2) == I &*& I != intUndef
  ensures unchanged(x)

lemma lemma_disj_gamma(I1: Interface, I2: Interface,
                       x: Node, xlock: Int, xlen: Int, xrangeLb: Int, xrangeUb: Int, xkeys: Array<Int>, xptrs: Array<Node>, Ix: Interface, I3: Interface)
  returns (I4: Interface)
  requires (Gr(I1) &*& Gr(I2)) && ([gamma(x, Ix)](Ix) &*& Gr(I3))
  requires ndLeq(Ix.na, I1.na) == false
  ensures Gr(I1) &*& [gamma(x, Ix)](Ix) &*& Gr(I4)
    &*& I2 == intComp(Ix, I4) &*& I3 == intComp(I1, I4)
  ensures unchanged(x)


/** Begin programs */

var TID: Int;

var r: Node;
axiom r != null; // TODO move to intValid. Should follow from r in I.FP


define globalInt(I) {
  intValid(I) == true && r in I.FP && (forall k: Int :: I.inf[r].ks[k] == 1)
    && (forall n: Node :: n != r ==> domEq(I.inf[n], domZero())
       @(matching n yields I.inf[n]))  // TODO ask Thomas -- field Read exceptions?
    && I.FPo == {}
}


procedure inRange(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I) && (res ==> Ix.inf[x].ks[k] >= 1)
{
  lemma_conc(x, Ix);

  var res1 := x.rangeLb <= k;
  // TODO add split here
  var res2 := x.rangeUb > k;

  lemma_abs(x, Ix, Ix);
  sync(Ix, Ix);

  if (res1 && res2)
    return true;
  else
    return false;
}

procedure findNext(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (n: Node)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I)
  ensures (n != null && Ix.fm[x][n].ks[k] >= 1
           || n == null && (forall y: Node :: Ix.fm[x][y].ks[k] == 0))
{
  lemma_conc(x, Ix);
  
  if (x.ptrs[0] == null) {  // Leaf node
    lemma_conc_rev(x, Ix);
    lemma_int_valid_unfold(Ix);
    return null;
  }

  var i := 0;
  var flag := true;

  while (flag)
    invariant [gamma(x, Ix)](Ix) &*& Gr(I2)
    invariant intValid(Ix) == true && intValid(I2) == true
    invariant intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
    invariant !flag ==> (i >= x.len || k < x.keys[i])
    invariant (i == 0 || x.keys[i-1] <= k) && 0 <= i && i <= x.len
  {
    if (i < x.len && x.keys[i] <= k) {
      i := i + 1;
    } else {
      flag := false;
    }
  }

  n := x.ptrs[i];
  lemma_conc_rev(x, Ix);
  // return n;
}

// A content witness for each loop iteration of delete
function cw(x: Node, Ix: Interface, j: Int, k: Int) returns (idx: Int)

procedure delete(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  requires Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == {locked(TID)}
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures Ix1.na.contents == Ix.na.contents -- {k} && (res == k in Ix.na.contents)
{
  lemma_conc(x, Ix);
  pure assume x.ptrs[0] == null; // x is a leaf.
  // TODO prove using induction from gamma & k !in any outgoing edgeset
    
  var i := 0;
  var flag := true;

  while (flag)
    invariant spl_state_ad(x, Ix, I2, I, k, i, flag)
  {
    if (i < x.len && x.keys[i] < k) {
      i := i + 1;
    } else {
      flag := false;
    }
  }

  if (i == x.len || x.keys[i] != k) {
    lemma_conc_rev(x, Ix);
    return false, Ix, I;
  } else {
    // Change nodel label to allow breaking gammaG
    var Ix2: Interface;
    pure assume Ix2 != intUndef && Ix2.na.lockinfo == {dirtylock(TID)}
      && Ix2.na.contents == Ix.na.contents
      && Ix2.FP == Ix.FP && Ix2.FPo == Ix.FPo && Ix2.inf == Ix.inf && Ix2.fm == Ix.fm
      // TODO needed to prove intValid(Ix2);
      && (forall n: Node, n1: Node :: n !in Ix.FP ==> domEq(domZero(), Ix.inf[n])
         @(matching Ix2.inf[n] yields Ix.inf[n].ks)
         @(matching Ix2.fm[n][n1] yields Ix.fm[n][n1].ks));
    lemma_int_valid_unfold(Ix);
    lemma_int_valid_fold(Ix2);
    gamma_sync(x, x.lock, x.len, x.rangeLb, x.rangeUb, x.keys, x.ptrs, Ix, Ix2);
    var I3 := lemma_gamma_comp_sing_int(x, x.lock, x.len, x.rangeLb, x.rangeUb, x.keys, x.ptrs, Ix2, I2);
    lemma_repl(I, Ix, I2, Ix2, I3);

    var j := i;
    pure assume forall k1: Int :: cw(x, Ix2, j, k1) == cont_witness(x, Ix, k1)
      @(matching cw(x, Ix2, j, k1) yields x.keys[cont_witness(x, Ix, k1)]);

    while (j < x.len - 1)
      invariant spl_state_ab(x, Ix, Ix2, I2, I3, i, j, k)
    {
      x.keys[j] := x.keys[j + 1];
      j := j + 1;

      pure assume forall k1: Int :: k1 != x.keys[j] && cw(x, Ix2, j, k1) == cw(x, Ix2, j-1, k1)
        || k1 == x.keys[j] && cw(x, Ix2, j, k1) == j-1;
    }
    x.len := x.len - 1; // TODO add this to paper!!

    // Change node label back, remove k from contents
    havoc Ix1;
    pure assume Ix1 != intUndef && Ix1.na.lockinfo == {locked(TID)}
                && Ix1.na.contents == Ix2.na.contents -- {k}
                && Ix1.FP == Ix2.FP && Ix1.FPo == Ix2.FPo
                && Ix1.inf == Ix2.inf && Ix1.fm == Ix2.fm
                && (forall k1: Int :: cont_witness(x, Ix1, k1) == cw(x, Ix2, j, k1)
                   @(matching cont_witness(x, Ix, k1) yields // Needed for lemma_abs
                     x.keys[cw(x, Ix2, j, k1)]));
    lemma_int_valid_unfold(Ix2);
    lemma_int_valid_fold(Ix1);

    lemma_abs(x, Ix2, Ix1);
    sync(Ix2, Ix1);
    var I4 := lemma_Gr_comp_int(Ix1, I2);
    lemma_repl(I3, Ix2, I2, Ix1, I4);
    return true, Ix1, I4;
  }
}


/* Intermediate states */

define spl_state_ac(x, Ix, I2, I) {
  [gamma(x, Ix)](Ix) &*& Gr(I2)
    &*& (intValid(Ix) == true && intValid(I2) == true && intComp(Ix, I2) == I
       && globalInt(I))
}

define spl_state_ad(x, Ix, I2, I, k, i, flag) {
  spl_state_ac(x, Ix, I2, I)
    &*& (Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
       && (!flag ==> (i >= x.len || k <= x.keys[i]))
       && (i == 0 || x.keys[i-1] < k) && 0 <= i && i <= x.len
       && Ix.na.lockinfo == {locked(TID)})
}

define spl_state_ab(x, Ix, Ix2, I2, I3, i, j, k) {
  spl_state_ac(x, Ix2, I2, I3)
    &*& (intEq(Ix, Ix2) == true && Ix2.na.lockinfo == {dirtylock(TID)}
       && 0 <= j && j <= x.len - 1
       && (forall k: Int :: (Ix2.inf[x].ks[k] >= 1) == (x.rangeLb <= k && k < x.rangeUb))
       && (forall l1: Int, l2: Int ::
          (0 <= l1 && l1 < l2 && l2 < j || j <= l1 && l1 < l2 && l2 < x.len)
          ==> x.keys[l1] < x.keys[l2])
       && (j == 0 || x.keys[j-1] <= x.keys[j])
       && (forall l: Int :: 0 <= l && l < x.ptrs.length ==> x.ptrs[l] == null) && Ix2.FPo == {}
       && Ix2.na.contents == Ix.na.contents && k in Ix.na.contents
       && (forall l: Int :: 0 <= l && l < x.len ==> x.keys[l] in Ix2.na.contents)
       && (forall k1: Int :: (k1 in Ix2.na.contents || k1 == k && j == i)
          ==> (k1 == x.keys[cw(x, Ix2, j, k1)])
          && 0 <= cw(x, Ix2, j, k1) && cw(x, Ix2, j, k1) < x.len)
       && (forall l: Int :: 0 <= l && l < j ==> x.keys[l] != k)
       )
}


/** Actions */

define action_lock_pre(x, Ix) {
  N(x, Ix) &*& Ix.na.lockinfo == {unlocked}
}

define action_lock_post(x, Ix, Ix1, t) {
  N(x, Ix1) &*& (Ix1.FP == Ix.FP && Ix1.FPo == Ix.FPo && Ix1.inf == Ix.inf
              && Ix1.fm == Ix.fm && Ix1.na.contents == Ix.na.contents
              && (Ix1.na.lockinfo == {locked(t)} || Ix1.na.lockinfo == {dirtylock(t)}))
}

procedure action_lock(x: Node, Ix: Interface, t: Int) returns (Ix1: Interface)
  requires action_lock_pre(x, Ix)
  ensures action_lock_post(x, Ix, Ix1, t)

define action_sync_pre(I, t) {
  Gr(I) &*& (I.na.lockinfo == {locked(t)} || I.na.lockinfo == {dirtylock(t)})
}

define action_sync_post(I, I1, t) {
  Gr(I1) &*& (I1.na.lockinfo == {unlocked} || I1.na.lockinfo == {locked(t)} || I1.na.lockinfo == {dirtylock(t)})
    &*& intEq(I, I1) == true
}

procedure action_sync(I: Interface, t: Int) returns (I1: Interface)
  requires action_sync_pre(I, t)
  ensures action_sync_post(I, I1, t)

define action_alloc_pre() { emp }

define action_alloc_post(x, Ix, t) {
  N(x, Ix) &*& (Ix.inf[x] == domZero() && Ix.FPo == {}
              && Ix.na.contents == {} && Ix.na.lockinfo == {dirtylock(t)})
}

procedure action_alloc(t: Int) returns (x: Node, Ix: Interface)
  requires action_alloc_pre()
  ensures action_alloc_post(x, Ix, t)


/** Stability proofs */

procedure stability_ac_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_ac(c, Ic, I2, I) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_ac(c, Ic, I21, I1)
{
  var I3 := lemma_disj_gamma(Ix, Io, c, c.lock, c.len, c.rangeLb, c.rangeUb, c.keys, c.ptrs, Ic, I2);

  var Ix1 := action_lock(x, Ix, t);
  // N(c, Ic) &*& N(x, Ix1) &*& Gr(I3)

  I21 := lemma_Gr_comp(Ix1, I3);
  I1 := lemma_gamma_comp_sing_int(c, c.lock, c.len, c.rangeLb, c.rangeUb, c.keys, c.ptrs, Ic, I21);
  // N(c, Ic) &*& Gr(I21)
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_valid_unfold(I1);
}

