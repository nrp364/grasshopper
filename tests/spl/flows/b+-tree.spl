/** B+ tree implementation of the give-up template for linearizable dictionaries. */

include "give-up-header.spl";
include "array_util.spl";


/** Instantiating give-up-header */

struct Node {
  var locktid: Int;
  var len: Int;
  var rangeLb: Int;
  var rangeUb: Int;
  var keys: Array<Int>;
  var ptrs: Array<Node>;
}

define unchanged(x) {
  x.locktid == old(x.locktid) && x.len == old(x.len) && x.rangeLb == old(x.rangeLb)
    && x.rangeUb == old(x.rangeUb) && x.keys == old(x.keys) && x.ptrs == old(x.ptrs)
}


/** Definition of good condition, gamma */

var B: Int;
axiom B > 1;

define gammaSpatial(x) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs)  
}

define gammaB(x, I) {
  x.locktid >= 0
    && (x.locktid > 0) == (I.na.lockinfo == locked(x.locktid) || I.na.lockinfo == dirtylock(x.locktid))
    && (x.locktid == 0) == (I.na.lockinfo == unlocked)
}

define gammaG(x, I) {
  0 <= x.len && x.len < 2*B && x.keys.length == 2*B && x.ptrs.length == 2*B && x.locktid >= 0
    && ((x.locktid == 0) == (I.na.lockinfo == unlocked))
    && (x.locktid > 0) == (I.na.lockinfo == locked(x.locktid) || I.na.lockinfo == dirtylock(x.locktid))
    && (forall k: Int :: (I.inf[x].ks[k] >= 1) == (x.rangeLb <= k < x.rangeUb))
    && (forall i: Int, j: Int :: 0 <= i < j < x.len ==> x.keys[i] < x.keys[j])
    && (x.ptrs[0] == null && I.FPo == {}  // Leaf
       && (forall i: Int :: 0 <= i < x.ptrs.length ==> x.ptrs[i] == null)
       && I.na.contents == set_of_array(x.keys, 0, x.len)
     || x.ptrs[0] != null  // Internal
       && I.na.contents == {}
       && (forall i: Int, k: Int :: 0 <= i <= x.len ==>
          x.ptrs[i] != null && x.ptrs[i] in I.FPo
          && ((I.fm[x][x.ptrs[i]].ks[k] >= 1) ==
             ((i <= 0 || x.keys[i-1] <= k) && (i >= x.len || k < x.keys[i])))
          @(matching x.ptrs[i] yields x.keys[i-1])
          @(matching x.ptrs[i] yields x.keys[i])))
}
/* TODO have a create B+ tree function to check this isn't unsat */


procedure newNode(xtid: Int, xlen: Int, xrangeLb: Int, xrangeUb: Int)
  returns (x: Node, Ix: Interface)
  requires emp
  ensures [acc(x) &*& acc(x.ptrs) &*& acc(x.keys)](Ix)
  ensures x.locktid == xtid && x.len == xlen && x.rangeLb == xrangeLb
  ensures x.rangeUb == xrangeUb && x.keys.length == 2*B && x.ptrs.length == 2*B
  ensures intValid(Ix) == true
  ensures Ix.FP == {x} && domEq(Ix.inf[x], domZero()) == true && Ix.FPo == {}


/** Lemmas to deal with conjunction */

// This follows from semantics of sync not modifying heap
procedure gamma_sync(x: Node, Ix: Interface, Ix1: Interface)
  returns ()
  requires [gamma(x, Ix1)](Ix) &*& intValid(Ix1) == true &*& intEq(Ix, Ix1) == true
  ensures [gamma(x, Ix1)](Ix1) &*& unchanged(x)

lemma lemma_gamma_comp_sing_int(x: Node, Ix: Interface, I2: Interface)
  returns (I: Interface)
  requires [gamma(x, Ix)](Ix) &*& Gr(I2)
  ensures [gamma(x, Ix)](Ix) &*& Gr(I2) &*& intComp(Ix, I2) == I &*& I != intUndef
  ensures unchanged(x)

lemma lemma_disj_gamma(I1: Interface, I2: Interface,
                       x: Node, Ix: Interface, I3: Interface)
  returns (I4: Interface)
  requires (Gr(I1) &*& Gr(I2)) && ([gamma(x, Ix)](Ix) &*& Gr(I3))
  requires ndLeq(Ix.na, I1.na) == false
  ensures Gr(I1) &*& [gamma(x, Ix)](Ix) &*& Gr(I4)
    &*& I2 == intComp(Ix, I4) &*& I3 == intComp(I1, I4)
  ensures unchanged(x)


/** Begin programs */

var TID: Int;
axiom TID > 0;
var r: Node;


procedure lock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires spl_state_aa(x, Ix, I2, I)
  ensures spl_state_ab(x, Ix1, I2, I1)
{
  lemma_conc(x, Ix);

  // CAS(x.locktid, 0, TID)
  if (x.locktid == 0) {
    x.locktid := TID;

    pure assume Ix1 != intUndef && Ix1.inf == Ix.inf && Ix1.na.contents == Ix.na.contents && Ix1.na.lockinfo == locked(TID) && Ix1.fm == Ix.fm && Ix1.FP == Ix.FP && Ix1.FPo == Ix.FPo;
    lemma_int_valid_unfold(Ix);
    lemma_int_valid_fold(Ix1);
    lemma_abs(x, Ix, Ix1);
    sync(Ix, Ix1);
    I1 := lemma_Gr_comp_int(Ix1, I2);
    lemma_repl(I, Ix, I2, Ix1, I1);
  } else {
    lemma_conc_rev(x, Ix);
    Ix1, I1 := lock(x, Ix, I2, I);
  }
}

procedure unlock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires spl_state_ab(x, Ix, I2, I)
  ensures spl_state_aa(x, Ix1, I2, I1)
{
  lemma_conc(x, Ix);

  x.locktid := 0;

  pure assume Ix1 != intUndef && Ix1.inf == Ix.inf && Ix1.na.contents == Ix.na.contents && Ix1.na.lockinfo == unlocked && Ix1.fm == Ix.fm && Ix1.FP == Ix.FP && Ix1.FPo == Ix.FPo;
  lemma_int_valid_unfold(Ix);
  lemma_int_valid_fold(Ix1);
  lemma_abs(x, Ix, Ix1);
  sync(Ix, Ix1);
  I1 := lemma_Gr_comp_int(Ix1, I2);
  lemma_repl(I, Ix, I2, Ix1, I1);
}

procedure inRange(x: Node, k: Int, Ix: Interface)
  returns (res: Bool)
  requires gamma(x, Ix) &*& Ix.na.lockinfo == locked(TID)
  ensures gamma(x, Ix) &*& (res ==> Ix.inf[x].ks[k] >= 1)
{
  if (x.rangeLb <= k && x.rangeUb > k)
    return true;
  else
    return false;
}

procedure findNext(x: Node, k: Int, Ix: Interface)
  returns (n: Node)
  requires gamma(x, Ix)
  requires intValid(Ix) == true && Ix.na.lockinfo == locked(TID)
  ensures gamma(x, Ix)
  ensures (n != null && Ix.fm[x][n].ks[k] >= 1
           || n == null && (forall y: Node :: Ix.fm[x][y].ks[k] == 0))
{
  if (x.ptrs[0] == null) {  // Leaf node
    lemma_int_valid_unfold(Ix);
    return null;
  }

  var i := 0;
  var flag := true;

  while (flag) // TODO need binary search upper bound in array_util.spl for this
    invariant gamma(x, Ix) &*& Ix.na.lockinfo == locked(TID)
    invariant !flag ==> (i >= x.len || k < x.keys[i])
    invariant (i == 0 || x.keys[i-1] <= k) && 0 <= i && i <= x.len
  {
    if (i < x.len && x.keys[i] <= k) {
      i := i + 1;
    } else {
      flag := false;
    }
  }

  n := x.ptrs[i];
  // return n;
}


procedure member(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == locked(TID)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures Ix1.na.contents == Ix.na.contents && (res == k in Ix.na.contents)
{
  lemma_conc(x, Ix);
  pure assume x.ptrs[0] == null; // x is a leaf.
  // TODO prove using induction from gamma & k !in any outgoing edgeset

  ghost var m := map_of_array(x.keys);

  var idx: Int;
  res, idx := arr_find(x.keys, x.len, k, m);

  lemma_conc_rev(x, Ix);

  return res, Ix, I;
}


procedure insert(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  requires Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == locked(TID)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures Ix1.na.contents == Ix.na.contents ++ {k} && (res == k !in Ix.na.contents)
{
  lemma_conc(x, Ix);
  pure assume x.ptrs[0] == null; // x is a leaf.
  // TODO prove using induction from gamma & k !in any outgoing edgeset

  pure assume x.len < 2*B - 1; // TODO allow insert to give up if full
  
  // Change nodel label to allow breaking gammaG
  var Ix2: Interface;
  pure assume Ix2 != intUndef && Ix2.na.lockinfo == dirtylock(TID)
    && Ix2.na.contents == Ix.na.contents
    && Ix2.FP == Ix.FP && Ix2.FPo == Ix.FPo && Ix2.inf == Ix.inf && Ix2.fm == Ix.fm
    // TODO needed to prove intValid(Ix2);
    && (forall n: Node, n1: Node :: n !in Ix.FP ==> domEq(domZero(), Ix.inf[n])
       @(matching Ix2.inf[n] yields Ix.inf[n].ks)
       @(matching Ix2.fm[n][n1] yields Ix.fm[n][n1].ks));
  lemma_int_valid_unfold(Ix);
  lemma_int_valid_fold(Ix2);
  gamma_sync(x, Ix, Ix2);
  var I3 := lemma_gamma_comp_sing_int(x, Ix2, I2);
  lemma_repl(I, Ix, I2, Ix2, I3);

  ghost var m := map_of_array(x.keys);

  var idx, new_len, m1 := arr_insert(x.keys, k, x.len, m); // TODO argument order consistent

  map_insert_content_set(m, m1, idx, k, x.len, new_len);

  x.len := new_len;

  // Change node label back, remove k from contents
  pure assume Ix1 != intUndef && Ix1.na.lockinfo == locked(TID)
    && Ix1.na.contents == Ix2.na.contents ++ {k}
    && Ix1.FP == Ix2.FP && Ix1.FPo == Ix2.FPo
    && Ix1.inf == Ix2.inf && Ix1.fm == Ix2.fm;
  lemma_int_valid_unfold(Ix2);
  lemma_int_valid_fold(Ix1);
  lemma_abs(x, Ix2, Ix1);
  sync(Ix2, Ix1);
  var I4 := lemma_Gr_comp_int(Ix1, I2);
  lemma_repl(I3, Ix2, I2, Ix1, I4);

  if (k in Ix.na.contents)  // TODO why?
    return false, Ix1, I4;
  else
    return true, Ix1, I4;
}


procedure delete(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  requires Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == locked(TID)
  ensures intEq(Ix, Ix1) == true
  // decisiveOpSpec(x, Ix1, res, k):
  ensures Ix1.na.contents == Ix.na.contents -- {k} && (res == k in Ix.na.contents)
{
  lemma_conc(x, Ix);
  pure assume x.ptrs[0] == null; // x is a leaf.
  // TODO prove using induction from gamma & k !in any outgoing edgeset
    
  // Change nodel label to allow breaking gammaG
  var Ix2: Interface;
  pure assume Ix2 != intUndef && Ix2.na.lockinfo == dirtylock(TID)
    && Ix2.na.contents == Ix.na.contents
    && Ix2.FP == Ix.FP && Ix2.FPo == Ix.FPo && Ix2.inf == Ix.inf && Ix2.fm == Ix.fm
    // TODO needed to prove intValid(Ix2);
    && (forall n: Node, n1: Node :: n !in Ix.FP ==> domEq(domZero(), Ix.inf[n])
       @(matching Ix2.inf[n] yields Ix.inf[n].ks)
       @(matching Ix2.fm[n][n1] yields Ix.fm[n][n1].ks));
  lemma_int_valid_unfold(Ix);
  lemma_int_valid_fold(Ix2);
  gamma_sync(x, Ix, Ix2);
  var I3 := lemma_gamma_comp_sing_int(x, Ix2, I2);
  lemma_repl(I, Ix, I2, Ix2, I3);

  ghost var m := map_of_array(x.keys);

  var new_len, idx, m1 := arr_delete(x.keys, k, x.len, m);

  arr_delete_content_set(m, m1, x.len, new_len, idx, k);

  x.len := new_len;

  // Change node label back, remove k from contents
  pure assume Ix1 != intUndef && Ix1.na.lockinfo == locked(TID)
    && Ix1.na.contents == Ix2.na.contents -- {k}
    && Ix1.FP == Ix2.FP && Ix1.FPo == Ix2.FPo
    && Ix1.inf == Ix2.inf && Ix1.fm == Ix2.fm;
  lemma_int_valid_unfold(Ix2);
  lemma_int_valid_fold(Ix1);
  lemma_abs(x, Ix2, Ix1);
  sync(Ix2, Ix1);
  var I4 := lemma_Gr_comp_int(Ix1, I2);
  lemma_repl(I3, Ix2, I2, Ix1, I4);

  return (k in Ix2.na.contents), Ix1, I4;
}


/* Intermediate states */

define spl_state_aa(x, Ix, I2, I) {
  N(x, Ix) &*& Gr(I2)
    &*& (intValid(Ix) == true && intValid(I2) == true && intComp(Ix, I2) == I && globalInt(I))
}

define spl_state_ab(x, Ix, I2, I) {
  N(x, Ix) &*& Gr(I2)
    &*& (intValid(Ix) == true && intValid(I2) == true && intComp(Ix, I2) == I && globalInt(I)
    && Ix.na.lockinfo == locked(TID))
}

define spl_state_ac(x, Ix, I2, I) {
  [gamma(x, Ix)](Ix) &*& Gr(I2)
    &*& (intValid(Ix) == true && intValid(I2) == true && intComp(Ix, I2) == I && globalInt(I))
}

define spl_state_ba(x, Ix, I2, I, k) {
  spl_state_aa(x, Ix, I2, I) &*& (Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0))
}


define spl_state_ad(x, Ix, I2, I, k, i, flag) {
  spl_state_ac(x, Ix, I2, I)
    &*& (Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
       && (!flag ==> (i >= x.len || k <= x.keys[i]))
       && (i == 0 || x.keys[i-1] < k) && 0 <= i && i <= x.len
       && Ix.na.lockinfo == locked(TID))
}


/** Stability proofs */

/*
procedure stability_ac_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_ac(c, Ic, I2, I) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_ac(c, Ic, I21, I1)
{
  var I3 := lemma_disj_gamma(Ix, Io, c, Ic, I2);

  var Ix1 := action_lock(x, Ix, t);
  // N(c, Ic) &*& N(x, Ix1) &*& Gr(I3)

  I21 := lemma_Gr_comp(Ix1, I3);
  I1 := lemma_gamma_comp_sing_int(c, Ic, I21);
  // N(c, Ic) &*& Gr(I21)
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_valid_unfold(I1);
}

 */
