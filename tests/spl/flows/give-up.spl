/** Give-up technique template for linearizable dictionaries. */

include "../include/flows.spl";


/** Flow domain definitions */

datatype FlowDom = fd(ks: Map<Int, Int>);

predicate domEq(p1: FlowDom, p2: FlowDom) {
  forall k: Int :: p1.ks[k] == p2.ks[k]
    @(matching p1.ks[k] yields p2.ks[k]) @(matching p2.ks[k] yields p1.ks[k])
}

predicate domLeq(p1: FlowDom, p2: FlowDom) {
  forall k: Int :: p1.ks[k] <= p2.ks[k]
}

function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
  ensures forall k: Int :: p.ks[k] == p1.ks[k] + p2.ks[k]

function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
  ensures forall k: Int :: p.ks[k] == p1.ks[k] * p2.ks[k]

function domZero() returns(p: FlowDom)
  ensures forall k: Int :: p.ks[k] == 0

datatype LockInfo = unlocked | locked(tid: Int) | dirtylock(dtid: Int) | lockTop;

datatype NodeDom = nd(contents: Set<Int>, lockinfo: LockInfo);

predicate ndLeq(a1: NodeDom, a2: NodeDom) {
  (forall x: Int :: x in a1.contents ==> x in a2.contents)
    && (a1.lockinfo == a2.lockinfo || a2.lockinfo == lockTop)
}


struct Node {}


/** Definition of good condition, gamma */

predicate gammaG(x: Node, I: Interface)

predicate gammaB(x: Node, I: Interface)

define gamma(x, I) {
  (gammaG(x, I) && I.na.lockinfo == locked(TID)
   || gammaB(x, I) && I.na.lockinfo == dirtylock(TID))
    &*& ((forall k: Int :: k in I.na.contents ==> I.inf[x].ks[k] >= 1)
       && (forall k: Int, y: Node :: k !in I.na.contents || I.fm[x][y].ks[k] == 0)
       && (forall k: Int, y: Node, z: Node :: y == z
          || I.fm[x][y].ks[k] == 0 || I.fm[x][z].ks[k] == 0))
}


/** Begin programs */

var TID: Int;


define globalInt(I) {
  intValid(I) == true && r in I.FP && (forall k: Int :: I.inf[r].ks[k] == 1)
    && (forall n: Node :: n != r ==> domEq(I.inf[n], domZero())
       @(matching n yields I.inf[n]))  // TODO ask Thomas
    && I.FPo == {}
}

var r: Node;
axiom r != null; // TODO move to intValid. Should follow from r in I.FP

procedure lock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && intEq(Ix, Ix1) == true
  ensures Ix1.na.lockinfo == locked(TID)


procedure unlock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && intEq(Ix, Ix1) == true


procedure inRange(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I) && (res ==> Ix.inf[x].ks[k] >= 1)


procedure findNext(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (n: Node)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I)
  ensures (n != null && Ix.fm[x][n].ks[k] >= 1
           || n == null && (forall y: Node :: Ix.fm[x][y].ks[k] == 0))


// To be filled-in by implementation:
predicate decisiveOpSpec(x: Node, Ix1: Interface, res: Bool, k: Int)

procedure decisiveOp(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == locked(TID)
  requires Ix.inf[x].ks[k] >= 1 && (forall y: Node :: Ix.fm[x][y].ks[k] == 0)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == locked(TID)
  ensures intEq(Ix, Ix1) == true // TODO why needed?
  ensures decisiveOpSpec(x, Ix1, res, k) == true


procedure dictionaryOp(k: Int, I: Interface) returns (res: Bool, I1: Interface)
  requires Gr(I) &*& globalInt(I)
  ensures Gr(I1) &*& globalInt(I1)
{
  var c := r;

  var Ic: Interface, I2: Interface;
  Ic, I2 := lemma_decomp(c, I);
  split spl_state_07(c, Ic, I2, I);

  var n := c;
  while (n != null)
    invariant spl_state_inv(c, Ic, I2, I, k, n)
  {
    Ic, I := lock(c, Ic, I2, I);

    split spl_state_02(c, Ic, I2, I);

    if (inRange(c, k, Ic, I2, I)) {
      split spl_state_03(c, Ic, I2, I, k);

      n := findNext(c, k, Ic, I2, I);

      split spl_state_04(c, Ic, I2, I, k, n);

      if (n != null) {
        split spl_state_05(c, Ic, I2, I, k, n);

        var Ic1: Interface;
        Ic1, I := unlock(c, Ic, I2, I);

        // Step to n
        var In: Interface, I3: Interface, I4: Interface;
        lemma_int_valid_unfold(Ic);
        lemma_int_valid_unfold(Ic1);
        //        pure assume domZero().ks[k] <= domZero().ks[k];
        //        pure assume !domEq(Ic1.fm[c][n], domZero());
        lemma_step(Ic1, I2, I, c, n);
        In, I3 := lemma_decomp(n, I2);
        // N(c, Ic) &*& N(n, In) &*& Gr(I3)
        I4 := lemma_Gr_comp(Ic1, I3);
        // N(n, In) &*& Gr(I4)
        Ic, I2 := In, I4;

        split spl_state_06(n, Ic, I2, I);

        c := n;
      }
    } else {
      split spl_state_02(c, Ic, I2, I);

      n := r;

      split spl_state_08(c, Ic, I2, I, n);

      var Ic1: Interface;
      Ic1, I := unlock(c, Ic, I2, I);

      // Drop N(c, Ic), and decomp to get N(n, In)
      I := lemma_Gr_comp(Ic1, I2);
      Ic, I2 := lemma_decomp(n, I);

      split spl_state_07(n, Ic, I2, I);

      c := n;
    }
  }
  res, Ic, I := decisiveOp(c, k, Ic, I2, I);

  split spl_state_02(c, Ic, I2, I);

  Ic, I := unlock(c, Ic, I2, I);

  split spl_state_01(c, Ic, I2, I);

  I := lemma_Gr_comp(Ic, I2);
  return res, I;
}

/** Intermediate assertions */

define spl_state_01(c, Ic, I2, I) {
  N(c, Ic) &*& Gr(I2) &*& (I == intComp(Ic, I2) && globalInt(I))
}

define spl_state_02(c, Ic, I2, I) {
  N(c, Ic) &*& Gr(I2)
    &*& (I == intComp(Ic, I2) && globalInt(I) && Ic.na.lockinfo == locked(TID))
}

define spl_state_03(c, Ic, I2, I, k) {
  spl_state_02(c, Ic, I2, I) &*& Ic.inf[c].ks[k] >= 1
}

define spl_state_04(c, Ic, I2, I, k, n) {
  spl_state_02(c, Ic, I2, I) &*& Ic.inf[c].ks[k] >= 1
    &*& (n != null && Ic.fm[c][n].ks[k] >= 1
       || n == null && (forall y: Node :: Ic.fm[c][y].ks[k] == 0))
}

define spl_state_05(c, Ic, I2, I, k, n) {
  spl_state_02(c, Ic, I2, I)
    &*& (Ic.inf[c].ks[k] >= 1 && n != null && Ic.fm[c][n].ks[k] >= 1)
}

define spl_state_06(c, Ic, I2, I) {
  spl_state_01(c, Ic, I2, I) &*& c != null
}

define spl_state_07(c, Ic, I2, I) {
  spl_state_01(c, Ic, I2, I) &*& r == c
}

define spl_state_08(c, Ic, I2, I, n) {
  spl_state_02(c, Ic, I2, I) &*& r == n
}

define spl_state_inv(c, Ic, I2, I, k, n) {
  spl_state_01(c, Ic, I2, I)
    &*& (n == null ==> Ic.na.lockinfo == locked(TID)
                     && Ic.inf[c].ks[k] >= 1 && (forall y: Node :: Ic.fm[c][y].ks[k] == 0))
}

/** Actions */

define action_lock_pre(x, Ix) {
  N(x, Ix) &*& Ix.na.lockinfo == unlocked
}

define action_lock_post(x, Ix, Ix1, t) {
  N(x, Ix1) &*& (Ix1.FP == Ix.FP && Ix1.FPo == Ix.FPo && Ix1.inf == Ix.inf
              && Ix1.fm == Ix.fm && Ix1.na.contents == Ix.na.contents
              && (Ix1.na.lockinfo == locked(t) || Ix1.na.lockinfo == dirtylock(t)))
}

procedure action_lock(x: Node, Ix: Interface, t: Int) returns (Ix1: Interface)
  requires action_lock_pre(x, Ix)
  ensures action_lock_post(x, Ix, Ix1, t)

define action_sync_pre(I, t) {
  Gr(I) &*& (I.na.lockinfo == locked(t) || I.na.lockinfo == dirtylock(t))
}

define action_sync_post(I, I1, t) {
  Gr(I1) &*& (I1.na.lockinfo == unlocked || I1.na.lockinfo == locked(t) || I1.na.lockinfo == dirtylock(t))
    &*& intEq(I, I1) == true
}

procedure action_sync(I: Interface, t: Int) returns (I1: Interface)
  requires action_sync_pre(I, t)
  ensures action_sync_post(I, I1, t)

define action_alloc_pre() { emp }

define action_alloc_post(x, Ix, t) {
  N(x, Ix) &*& (Ix.inf[x] == domZero() && Ix.FPo == {}
              && Ix.na.contents == {} && Ix.na.lockinfo == dirtylock(t))
}

procedure action_alloc(t: Int) returns (x: Node, Ix: Interface)
  requires action_alloc_pre()
  ensures action_alloc_post(x, Ix, t)

/** Stability proofs */

procedure stability_pre_lock(I: Interface, x: Node, Ix: Interface, I2: Interface, t: Int)
  returns (I1: Interface)
  requires (Gr(I) &*& globalInt(I)) && (action_lock_pre(x, Ix) &*& Gr(I2)) &*& t != TID
  ensures Gr(I1) &*& globalInt(I1)
{
  lemma_Gr_comp_uniq(I, Ix, I2);

  var Ix1 := action_lock(x, Ix, t);

  I1 := lemma_Gr_comp(Ix1, I2);
  lemma_repl(I, Ix, I2, Ix1, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_pre_sync(I: Interface, Ix: Interface, I2: Interface, t: Int)
  returns (I1: Interface)
  requires (Gr(I) &*& globalInt(I)) && (action_sync_pre(Ix, t) &*& Gr(I2)) &*& t != TID
  ensures Gr(I1) &*& globalInt(I1)
{
  lemma_Gr_comp_uniq(I, Ix, I2);

  var Ix1 := action_sync(Ix, t);

  I1 := lemma_Gr_comp(Ix1, I2);
  lemma_repl(I, Ix, I2, Ix1, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_pre_alloc(I: Interface, I2: Interface, t: Int)
  returns (I1: Interface)
  requires (Gr(I) &*& globalInt(I)) && (action_alloc_pre() &*& Gr(I2)) &*& t != TID
  ensures Gr(I1) &*& globalInt(I1)
{
  lemma_Gr_uniq(I, I2);

  var x: Node, Ix: Interface;
  x, Ix := action_alloc(t);

  I1 := lemma_Gr_comp(Ix, I);
  lemma_add_singl(I, x, Ix, I1);
}

procedure stability_01_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (Ic1:Interface, I21: Interface, I1: Interface)
  requires spl_state_01(c, Ic, I2, I) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_01(c, Ic1, I21, I1)
{
  I := lemma_Gr_comp(Ic, I2);
  lemma_Gr_comp_uniq(I, Ix, Io);

  var Ix1 := action_lock(x, Ix, t);

  I1 := lemma_Gr_comp(Ix1, Io);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_valid_unfold(I1);
  Ic1, I21 := lemma_decomp(c, I1);
}

procedure stability_01_sync(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            Ix: Interface, Io: Interface, t: Int)
  returns (Ic1:Interface, I21: Interface, I1: Interface)
  requires spl_state_01(c, Ic, I2, I) && (action_sync_pre(Ix, t) &*& Gr(Io)) &*& t != TID
  ensures spl_state_01(c, Ic1, I21, I1)
{
  I := lemma_Gr_comp(Ic, I2);
  lemma_Gr_comp_uniq(I, Ix, Io);

  var Ix1 := action_sync(Ix, t);

  I1 := lemma_Gr_comp(Ix1, Io);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_valid_unfold(I1);
  Ic1, I21 := lemma_decomp(c, I1);
}

procedure stability_01_alloc(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            Io: Interface, t: Int)
  returns (Ic1:Interface, I21: Interface, I1: Interface)
  requires spl_state_01(c, Ic, I2, I) && (action_alloc_pre() &*& Gr(Io)) &*& t != TID
  ensures spl_state_01(c, Ic1, I21, I1)
{
  I := lemma_Gr_comp(Ic, I2);
  lemma_Gr_uniq(I, Io);

  var x: Node, Ix: Interface;
  x, Ix := action_alloc(t);

  I1 := lemma_Gr_comp(Ix, I);
  lemma_add_singl(I, x, Ix, I1);
  Ic1, I21 := lemma_decomp(c, I1);
}

procedure stability_02_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_02(c, Ic, I2, I) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_02(c, Ic, I21, I1)
{
  var I3 := lemma_disj(Ic, I2, x, Ix, Io);

  var Ix1 := action_lock(x, Ix, t);
  // N(c, Ic) &*& N(x, Ix1) &*& Gr(I3)

  I21 := lemma_Gr_comp(Ix1, I3);
  I1 := lemma_Gr_comp_int(Ic, I21);
  // N(c, Ic) &*& Gr(I21)
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_02_sync(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            Ix: Interface, Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_02(c, Ic, I2, I) && (action_sync_pre(Ix, t) &*& Gr(Io)) &*& t != TID
  ensures spl_state_02(c, Ic, I21, I1)
{
  var I3 := lemma_disj(Ix, Io, c, Ic, I2);

  var Ix1 := action_sync(Ix, t);

  I21 := lemma_Gr_comp(Ix1, I3);
  I1 := lemma_Gr_comp_int(Ic, I21);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_02_alloc(c: Node, Ic: Interface, I2: Interface, I: Interface,
                             Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_02(c, Ic, I2, I) && (action_alloc_pre() &*& Gr(Io)) &*& t != TID
  ensures spl_state_02(c, Ic, I21, I1)
{
  lemma_Gr_comp_uniq(Io, Ic, I2);

  var x: Node, Ix: Interface;
  x, Ix := action_alloc(t);

  I21 := lemma_Gr_comp(I2, Ix);
  I1 := lemma_Gr_comp_int(Ic, I21);
  lemma_add_singl(I, x, Ix, I1);
}

procedure stability_inv_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                             k: Int, n: Node,
                             x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (Ic1: Interface, I21: Interface, I1: Interface)
  requires spl_state_inv(c, Ic, I2, I, k, n) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_inv(c, Ic1, I21, I1, k, n)
{
  if (n == null) {
    I21, I1 := stability_02_lock(c, Ic, I2, I, x, Ix, Io, t);
    Ic1 := Ic;
  } else {
    Ic1, I21, I1 := stability_01_lock(c, Ic, I2, I, x, Ix, Io, t);
  }
}

procedure stability_inv_sync(c: Node, Ic: Interface, I2: Interface, I: Interface,
                             k: Int, n: Node,
                             Ix: Interface, Io: Interface, t: Int)
  returns (Ic1: Interface, I21: Interface, I1: Interface)
  requires spl_state_inv(c, Ic, I2, I, k, n) && (action_sync_pre(Ix, t) &*& Gr(Io)) &*& t != TID
  ensures spl_state_inv(c, Ic1, I21, I1, k, n)
{
  if (n == null) {
    I21, I1 := stability_02_sync(c, Ic, I2, I, Ix, Io, t);
    Ic1 := Ic;
  } else {
    Ic1, I21, I1 := stability_01_sync(c, Ic, I2, I, Ix, Io, t);
  }
}

procedure stability_inv_alloc(c: Node, Ic: Interface, I2: Interface, I: Interface,
                             k: Int, n: Node,
                             Io: Interface, t: Int)
  returns (Ic1: Interface, I21: Interface, I1: Interface)
  requires spl_state_inv(c, Ic, I2, I, k, n) && (action_alloc_pre() &*& Gr(Io)) &*& t != TID
  ensures spl_state_inv(c, Ic1, I21, I1, k, n)
{
  if (n == null) {
    I21, I1 := stability_02_alloc(c, Ic, I2, I, Io, t);
    Ic1 := Ic;
  } else {
    Ic1, I21, I1 := stability_01_alloc(c, Ic, I2, I, Io, t);
  }
}
