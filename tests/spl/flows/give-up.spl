/** Give-up template for linearizable dictionaries. */

include "../include/flows.spl";


/** Flow domain definitions */

datatype FlowDom = fd(ks: Set<Int>);

function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{ fd(p1.ks ++ p2.ks) }

function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{ fd(p1.ks ** p2.ks) }

function domZero() returns(p: FlowDom) { fd({}) }

datatype LockInfo = unlocked | locked(tid: Int) | dirtylock(dtid: Int);

datatype NodeDom = nd(contents: Set<Int>, lockinfo: Set<LockInfo>);
// TODO can do with LockInfo instead of Set<LockInfo>?

predicate ndLeq(a1: NodeDom, a2: NodeDom) {
  (forall x: Int :: x in a1.contents ==> x in a2.contents)
    && (forall l: LockInfo :: l in a1.lockinfo ==> l in a2.lockinfo)
}


struct Node {}


/** Definition of good condition, gamma */

predicate gammaG(x: Node, I: Interface)

predicate gammaB(x: Node, I: Interface)  // TODO why did we need two?


procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires I != intUndef
  requires N(x, I)
  ensures [gammaG(x, I)](I) &*& I.FP == {x}
  ensures forall k: Int :: k in I.na.contents ==> k in I.inf[x].ks
  ensures forall k: Int, y: Node :: k !in I.na.contents || k !in I.fm[x][y].ks
  ensures forall k: Int, y: Node, z: Node :: k !in I.fm[x][y].ks || k !in I.fm[x][z].ks

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires I != intUndef && I1 != intUndef && intValid(I1)
  requires [gammaG(x, I1)](I) &*& I1.FP == {x}
  requires forall k: Int :: k in I1.na.contents ==> k in I1.inf[x].ks
  requires forall k: Int, y: Node :: k !in I1.na.contents || k !in I1.fm[x][y].ks
  requires forall k: Int, y: Node, z: Node :: k !in I1.fm[x][y].ks || k !in I1.fm[x][z].ks
  ensures [N(x, I1)](I)


/** Begin programs */

var TID: Int;


define globalInt(I) {
  intValid(I) == true && r in I.FP && (forall k: Int :: k in I.inf[r].ks)
  && (forall n: Node :: n != r ==> I.inf[n] == domZero()) && I.FPo == {}
};

var r: Node;
axiom r != null; // TODO move to intValid. Should follow from r in I.FP

procedure lock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && intLeq(Ix, Ix1)
  ensures Ix1.na.lockinfo == {locked(TID)}


procedure unlock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && intLeq(Ix, Ix1)


procedure inRange(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I) && (res ==> k in Ix.inf[x].ks)


procedure findNext(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (n: Node)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I)
  ensures (n != null && k in Ix.fm[x][n].ks
           || n == null && (forall y: Node :: k !in Ix.fm[x][y].ks))


// To be filled-in by implementation:
predicate decisiveOpSpec(x: Node, Ix1: Interface, res: Bool, k: Int)

procedure decisiveOp(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  requires k in Ix.inf[x].ks && (forall y: Node :: k !in Ix.fm[x][y].ks)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == {locked(TID)}
  ensures intLeq(Ix, Ix1) == true // TODO why needed?
  ensures decisiveOpSpec(x, Ix1, res, k) == true


procedure dictionaryOp(k: Int, I: Interface) returns (res: Bool, I1: Interface)
  requires Gr(I) &*& globalInt(I)
  ensures Gr(I1) &*& globalInt(I1)
{
  var c := r;

  var Ic: Interface, I2: Interface;
  Ic, I2 := lemma_decomp(c, I);
  split spl_state_01(c, Ic, I2, I) &*& r == c;  // TODO r == c okay?

  var n := c;
  while (n != null)
    invariant N(c, Ic) &*& Gr(I2) &*& (I == intComp(Ic, I2) && globalInt(I))
    invariant (n == null ==> Ic.na.lockinfo == {locked(TID)}
                            && k in Ic.inf[c].ks && (forall y: Node :: k !in Ic.fm[c][y].ks))
  {
    Ic, I := lock(c, Ic, I2, I);

    split spl_state_02(c, Ic, I2, I);

    if (inRange(c, k, Ic, I2, I)) {
      split spl_state_03(c, Ic, I2, I, k);

      n := findNext(c, k, Ic, I2, I);

      split spl_state_04(c, Ic, I2, I, k, n);

      if (n != null) {
        split spl_state_05(c, Ic, I2, I, k, n);

        var Ic1: Interface;
        Ic1, I := unlock(c, Ic, I2, I);

        // Step to n
        var In: Interface, I3: Interface, I4: Interface;
        lemma_int_leq_unfold(Ic, Ic1);
        lemma_int_valid_unfold(Ic);
        lemma_step(Ic1, I2, I, c, n);
        In, I3 := lemma_decomp(n, I2);
        // N(c, Ic) &*& N(n, In) &*& Gr(I3)
        I4 := lemma_Gr_comp(Ic1, I3);
        // N(n, In) &*& Gr(I4)
        Ic, I2 := In, I4;

        split spl_state_06(n, Ic, I2, I);

        c := n;
      }
    } else {
      split spl_state_02(c, Ic, I2, I);

      n := r;

      split spl_state_02(c, Ic, I2, I) &*& n == r;

      var Ic1: Interface;
      Ic1, I := unlock(c, Ic, I2, I);

      // Drop N(c, Ic), and decomp to get N(n, In)
      I := lemma_Gr_comp(Ic1, I2);
      Ic, I2 := lemma_decomp(n, I);

      split spl_state_01(n, Ic, I2, I) &*& r == n;

      c := n;
    }
  }
  res, Ic, I := decisiveOp(c, k, Ic, I2, I);

  split spl_state_02(c, Ic, I2, I);

  Ic, I := unlock(c, Ic, I2, I);

  split spl_state_01(c, Ic, I2, I);

  I := lemma_Gr_comp(Ic, I2);
  return res, I;
}

/** Intermediate assertions */

define spl_state_01(c, Ic, I2, I) {
  N(c, Ic) &*& Gr(I2) &*& (I == intComp(Ic, I2) && globalInt(I))
};

define spl_state_02(c, Ic, I2, I) {
  N(c, Ic) &*& Gr(I2)
    &*& (I == intComp(Ic, I2) && globalInt(I) && Ic.na.lockinfo == {locked(TID)})
};

define spl_state_03(c, Ic, I2, I, k) {
  N(c, Ic) &*& Gr(I2)
    &*& (I == intComp(Ic, I2) && globalInt(I) && Ic.na.lockinfo == {locked(TID)}
       && k in Ic.inf[c].ks)
};

define spl_state_04(c, Ic, I2, I, k, n) {
  N(c, Ic) &*& Gr(I2)
    &*& (I == intComp(Ic, I2) && globalInt(I) && Ic.na.lockinfo == {locked(TID)}
       && k in Ic.inf[c].ks
       && (n != null && k in Ic.fm[c][n].ks
          || n == null && (forall y: Node :: k !in Ic.fm[c][y].ks)))
};

define spl_state_05(c, Ic, I2, I, k, n) {
  N(c, Ic) &*& Gr(I2)
    &*& (I == intComp(Ic, I2) && globalInt(I) && Ic.na.lockinfo == {locked(TID)}
       && k in Ic.inf[c].ks && n != null && k in Ic.fm[c][n].ks)
};

define spl_state_06(c, Ic, I2, I) {
  N(c, Ic) &*& Gr(I2) &*& (I == intComp(Ic, I2) && globalInt(I) && c != null)
};

/** Actions */

define action_lock_pre(x, Ix) {
  N(x, Ix) &*& Ix.na.lockinfo == {unlocked}
};

define action_lock_post(x, Ix, Ix1, t) {
  N(x, Ix1) &*& (Ix1.FP == Ix.FP && Ix1.FPo == Ix.FPo && Ix1.inf == Ix.inf
              && Ix1.fm == Ix.fm && Ix1.na.contents == Ix.na.contents
              && (Ix1.na.lockinfo == {locked(t)} || Ix1.na.lockinfo == {dirtylock(t)}))
};

procedure action_lock(x: Node, Ix: Interface, t: Int) returns (Ix1: Interface)
  requires action_lock_pre(x, Ix)
  ensures action_lock_post(x, Ix, Ix1, t)

define action_sync_pre(I, t) {
  Gr(I) &*& (I.na.lockinfo == {locked(t)} || I.na.lockinfo == {dirtylock(t)})
};

define action_sync_post(I, I1, t) {
  Gr(I1) &*& (I1.na.lockinfo == {unlocked} || I1.na.lockinfo == {locked(t)} || I1.na.lockinfo == {dirtylock(t)})
    &*& intLeq(I, I1) == true
};

procedure action_sync(I: Interface, t: Int) returns (I1: Interface)
  requires action_sync_pre(I, t)
  ensures action_sync_post(I, I1, t)

define action_alloc_pre() { emp };

define action_alloc_post(x, Ix, t) {
  N(x, Ix) &*& (Ix.inf[x] == domZero() && Ix.FPo == {}
              && Ix.na.contents == {} && Ix.na.lockinfo == {dirtylock(t)})
};

procedure action_alloc(t: Int) returns (x: Node, Ix: Interface)
  requires action_alloc_pre()
  ensures action_alloc_post(x, Ix, t)

/** Stability proofs */

procedure stability_pre_lock(I: Interface, x: Node, Ix: Interface, I2: Interface, t: Int)
  returns (I1: Interface)
  requires (Gr(I) &*& globalInt(I)) && (action_lock_pre(x, Ix) &*& Gr(I2)) &*& t != TID
  ensures Gr(I1) &*& globalInt(I1)
{
  lemma_Gr_comp_uniq(I, Ix, I2);

  var Ix1 := action_lock(x, Ix, t);

  I1 := lemma_Gr_comp(Ix1, I2);
  lemma_int_leq_fold(Ix, Ix1);
  lemma_repl(I, Ix, I2, Ix1, I1);
  lemma_int_leq_unfold(I, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_pre_sync(I: Interface, Ix: Interface, I2: Interface, t: Int)
  returns (I1: Interface)
  requires (Gr(I) &*& globalInt(I)) && (action_sync_pre(Ix, t) &*& Gr(I2)) &*& t != TID
  ensures Gr(I1) &*& globalInt(I1)
{
  lemma_Gr_comp_uniq(I, Ix, I2);

  var Ix1 := action_sync(Ix, t);

  I1 := lemma_Gr_comp(Ix1, I2);
  lemma_repl(I, Ix, I2, Ix1, I1);
  lemma_int_leq_unfold(I, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_pre_alloc(I: Interface, I2: Interface, t: Int)
  returns (I1: Interface)
  requires (Gr(I) &*& globalInt(I)) && (action_alloc_pre() &*& Gr(I2)) &*& t != TID
  ensures Gr(I1) &*& globalInt(I1)
{
  lemma_Gr_uniq(I, I2);

  var x: Node, Ix: Interface;
  x, Ix := action_alloc(t);

  I1 := lemma_Gr_comp(Ix, I);
  lemma_add_singl(I, x, Ix, I1);
}

procedure stability_01_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (Ic1:Interface, I21: Interface, I1: Interface)
  requires spl_state_01(c, Ic, I2, I) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_01(c, Ic1, I21, I1)
{
  I := lemma_Gr_comp(Ic, I2);
  lemma_Gr_comp_uniq(I, Ix, Io);

  var Ix1 := action_lock(x, Ix, t);

  I1 := lemma_Gr_comp(Ix1, Io);
  lemma_int_leq_fold(Ix, Ix1);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_leq_unfold(I, I1);
  lemma_int_valid_unfold(I1);
  Ic1, I21 := lemma_decomp(c, I1);
}

procedure stability_01_sync(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            Ix: Interface, Io: Interface, t: Int)
  returns (Ic1:Interface, I21: Interface, I1: Interface)
  requires spl_state_01(c, Ic, I2, I) && (action_sync_pre(Ix, t) &*& Gr(Io)) &*& t != TID
  ensures spl_state_01(c, Ic1, I21, I1)
{
  I := lemma_Gr_comp(Ic, I2);
  lemma_Gr_comp_uniq(I, Ix, Io);

  var Ix1 := action_sync(Ix, t);

  I1 := lemma_Gr_comp(Ix1, Io);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_leq_unfold(I, I1);
  lemma_int_valid_unfold(I1);
  Ic1, I21 := lemma_decomp(c, I1);
}

procedure stability_01_alloc(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            Io: Interface, t: Int)
  returns (Ic1:Interface, I21: Interface, I1: Interface)
  requires spl_state_01(c, Ic, I2, I) && (action_alloc_pre() &*& Gr(Io)) &*& t != TID
  ensures spl_state_01(c, Ic1, I21, I1)
{
  I := lemma_Gr_comp(Ic, I2);
  lemma_Gr_uniq(I, Io);

  var x: Node, Ix: Interface;
  x, Ix := action_alloc(t);

  I1 := lemma_Gr_comp(Ix, I);
  lemma_add_singl(I, x, Ix, I1);
  Ic1, I21 := lemma_decomp(c, I1);
}

procedure stability_02_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_02(c, Ic, I2, I) && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures spl_state_02(c, Ic, I21, I1)
{
  var I3 := lemma_disj(Ic, I2, x, Ix, Io);

  var Ix1 := action_lock(x, Ix, t);
  // N(c, Ic) &*& N(x, Ix1) &*& Gr(I3)

  I21 := lemma_Gr_comp(Ix1, I3);
  I1 := lemma_Gr_comp_int(Ic, I21);
  // N(c, Ic) &*& Gr(I21)
  lemma_int_leq_fold(Ix, Ix1);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_leq_unfold(I, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_02_sync(c: Node, Ic: Interface, I2: Interface, I: Interface,
                            Ix: Interface, Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_02(c, Ic, I2, I) && (action_sync_pre(Ix, t) &*& Gr(Io)) &*& t != TID
  ensures spl_state_02(c, Ic, I21, I1)
{
  var I3 := lemma_disj(Ix, Io, c, Ic, I2);

  var Ix1 := action_sync(Ix, t);

  I21 := lemma_Gr_comp(Ix1, I3);
  I1 := lemma_Gr_comp_int(Ic, I21);
  lemma_repl(I, Ix, Io, Ix1, I1);
  lemma_int_leq_unfold(I, I1);
  lemma_int_valid_unfold(I1);
}

procedure stability_02_alloc(c: Node, Ic: Interface, I2: Interface, I: Interface,
                             Io: Interface, t: Int)
  returns (I21: Interface, I1: Interface)
  requires spl_state_02(c, Ic, I2, I) && (action_alloc_pre() &*& Gr(Io)) &*& t != TID
  ensures spl_state_02(c, Ic, I21, I1)
{
  lemma_Gr_comp_uniq(Io, Ic, I2);

  var x: Node, Ix: Interface;
  x, Ix := action_alloc(t);

  I21 := lemma_Gr_comp(I2, Ix);
  I1 := lemma_Gr_comp_int(Ic, I21);
  lemma_add_singl(I, x, Ix, I1);
}


procedure stability_inv_lock(c: Node, Ic: Interface, I2: Interface, I: Interface,
                             k: Int, n: Node,
                             x: Node, Ix: Interface, Io: Interface, t: Int)
  returns (Ic1: Interface, I21: Interface, I1: Interface)
  requires (N(c, Ic) &*& Gr(I2)
            &*& intValid(Ic) == true && intValid(I2) == true && intComp(Ic, I2) == I
            &*& globalInt(I)
            &*& (n == null ==> Ic.na.lockinfo == {locked(TID)}
                            && k in Ic.inf[c].ks && (forall y: Node :: k !in Ic.fm[c][y].ks)))
  && (action_lock_pre(x, Ix) &*& Gr(Io)) &*& t != TID
  ensures (N(c, Ic1) &*& Gr(I21)
           &*& intValid(Ic1) == true && intValid(I21) == true && intComp(Ic1, I21) == I1
           &*& globalInt(I1)
           &*& (n == null ==> Ic1.na.lockinfo == {locked(TID)}
                            && k in Ic1.inf[c].ks
                            && (forall y: Node :: k !in Ic1.fm[c][y].ks)))
