/** Give-up template for linearizable dictionaries. */

include "../include/flows.spl";


/** Flow domain definitions */

datatype FlowDom = fd(ks: Set<Int>);

function domPlus(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{ fd(p1.ks ++ p2.ks) }

function domMult(p1: FlowDom, p2: FlowDom) returns (p: FlowDom)
{ fd(p1.ks ** p2.ks) }

function domZero() returns(p: FlowDom) { fd({}) }

datatype LockInfo = unlocked | locked(tid: Int) | dirtylock(dtid: Int);

datatype NodeDom = nd(contents: Set<Int>, lockinfo: Set<LockInfo>);

struct Node {
}


/** Definition of good condition, gamma */

predicate gammaG(x: Node, I: Interface)

predicate gammaB(x: Node, I: Interface)  // TODO why did we need two?


procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires I != intUndef
  requires N(x, I)
  ensures [gammaG(x, I)](I) &*& I.FP == {x}
  ensures forall k: Int :: k in I.na.contents ==> k in I.inf[x].ks
  ensures forall k: Int, y: Node :: k !in I.na.contents || k !in I.fm[x][y].ks
  ensures forall k: Int, y: Node, z: Node :: k !in I.fm[x][y].ks || k !in I.fm[x][z].ks

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires I != intUndef && I1 != intUndef && intValid(I1)
  requires [gammaG(x, I1)](I) &*& I1.FP == {x}
  requires forall k: Int :: k in I1.na.contents ==> k in I1.inf[x].ks
  requires forall k: Int, y: Node :: k !in I1.na.contents || k !in I1.fm[x][y].ks
  requires forall k: Int, y: Node, z: Node :: k !in I1.fm[x][y].ks || k !in I1.fm[x][z].ks
  ensures [N(x, I1)](I)


/** Begin programs */

var TID: Int;


define globalInt(I) {
  intValid(I) == true && r in I.FP && (forall k: Int :: k in I.inf[r].ks)
  && (forall n: Node :: n != r ==> I.inf[n] == domZero()) && I.FPo == {}
};

var r: Node;

procedure lock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && intLeq(Ix, Ix1)
  ensures Ix1.na.lockinfo == {locked(TID)}


procedure unlock(x: Node, Ix: Interface, I2: Interface, I: Interface)
  returns (Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && intLeq(Ix, Ix1)


procedure inRange(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I) && (res ==> k in Ix.inf[x].ks)


procedure findNext(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (n: Node)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  ensures N(x, Ix) &*& Gr(I2)
  ensures intValid(Ix) == true && intValid(I2) == true
  ensures intComp(Ix, I2) == I && globalInt(I)
  ensures (n != null && k in Ix.fm[x][n].ks
           || n == null && (forall y: Node :: k !in Ix.fm[x][y].ks))


// To be filled-in by implementation:
predicate decisiveOpSpec(x: Node, Ix1: Interface, res: Bool, k: Int)

procedure decisiveOp(x: Node, k: Int, Ix: Interface, I2:Interface, I: Interface)
  returns (res: Bool, Ix1: Interface, I1: Interface)
  requires N(x, Ix) &*& Gr(I2)
  requires intValid(Ix) == true && intValid(I2) == true
  requires intComp(Ix, I2) == I && globalInt(I) && Ix.na.lockinfo == {locked(TID)}
  requires k in Ix.inf[x].ks && (forall y: Node :: k !in Ix.fm[x][y].ks)
  ensures N(x, Ix1) &*& Gr(I2)
  ensures intValid(Ix1) == true && intValid(I2) == true
  ensures intComp(Ix1, I2) == I1 && globalInt(I1) && Ix1.na.lockinfo == {locked(TID)}
  ensures intLeq(Ix, Ix1) == true // TODO why needed?
  ensures decisiveOpSpec(x, Ix1, res, k) == true


procedure dictionaryOp(k: Int, I: Interface) returns (res: Bool, I1: Interface)
  requires Gr(I) &*& globalInt(I) &*& r != null // TODO move to intValid
  ensures Gr(I1) &*& globalInt(I1)
{
  var c := r;
  var Ic: Interface, I2: Interface;
  Ic, I2 := lemma_decomp(c, I);

  var n := c;
  while (n != null)
    invariant N(c, Ic) &*& Gr(I2) &*& r != null
    invariant intValid(Ic) == true && intValid(I2) == true && intComp(Ic, I2) == I
    invariant globalInt(I)
    invariant (n == null ==> Ic.na.lockinfo == {locked(TID)}
                            && k in Ic.inf[c].ks && (forall y: Node :: k !in Ic.fm[c][y].ks))
  {
    Ic, I := lock(c, Ic, I2, I);

    if (inRange(c, k, Ic, I2, I)) {
      n := findNext(c, k, Ic, I2, I);

      if (n != null) {
        var Ic1: Interface;
        Ic1, I := unlock(c, Ic, I2, I);
             
        // Step to n
        var In: Interface, I3: Interface, I4: Interface;
        lemma_int_leq_unfold(Ic, Ic1);
        lemma_int_valid_unfold(Ic);
        pure assume Ic1.FP == {c};  // TODO
        lemma_step(Ic1, I2, I, c, n);
        In, I3 := lemma_decomp(n, I2);
        // N(c, Ic) &*& N(n, In) &*& Gr(I3)
        lemma_N_is_Gr(c, Ic1);
        I4 := lemma_Gr_comp(Ic1, I3);
        // N(n, In) &*& Gr(I4)
        Ic, I2 := In, I4;
        c := n;
      }
    } else {
      n := r;

      var Ic1: Interface;
      Ic1, I := unlock(c, Ic, I2, I);

      // Drop N(c, Ic), and decomp to get N(n, In)
      lemma_N_is_Gr(c, Ic1);
      I := lemma_Gr_comp(Ic1, I2);
      Ic, I2 := lemma_decomp(n, I);

      c := n;
    }
  }
  res, Ic, I := decisiveOp(c, k, Ic, I2, I);
  Ic, I := unlock(c, Ic, I2, I);

  lemma_N_is_Gr(c, Ic);
  I := lemma_Gr_comp(Ic, I2);
  return res, I;
}
