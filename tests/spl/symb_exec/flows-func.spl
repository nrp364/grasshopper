include "lemmas.spl";

function domPlus(p1: Int, p2: Int) returns (p: Int)
  ensures p == p1 + p2

function domMult(p1: Int, p2: Int) returns (p: Int)
  ensures p == p1 * p2

function domZero() returns(p: Int)
  ensures p == 0
  
struct Node {
  var next: Node;
}

datatype Interface =
  int(inf: Map<Node, Int>,
      fm: Map<Node, Map<Node, Int>>,
      FP: Set<Node>,
      FPo: Set<Node>)
  | intUndef; // All interfaces with > 1 inflow are undefined

/** Gamma is hardcoded into these two lemmas */

procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires I != intUndef
  requires N(x, I)
  ensures [acc(x) &*& I.inf[x] == 1 &*& (x.next == null && I.FPo == {} || x.next != null && I.FPo == {x.next} && I.fm[x][x.next] == 1)](I) &*& I.FP == {x}

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires I != intUndef && I1 != intUndef
  requires [acc(x) &*& I1.inf[x] == 1 &*& (x.next == null && I1.FPo == {} || x.next != null && I1.FPo == {x.next} && I1.fm[x][x.next] == 1)](I) &*& I1.FP == {x}
  ensures [N(x, I1)](I)


/** Lemmas */

// Sufficient condition for intComp(I, Ix, Iy), when Ix, Iy are singletons
procedure lemma_int_comp_fold(x: Node, Ix: Interface, y: Node, Iy: Interface, I: Interface)
  requires Ix != intUndef && Iy != intUndef && I != intUndef
  requires Ix.FP == {x} && Iy.FP == {y} && x != y && I.FP == {x, y}
  requires I.FPo == (Ix.FPo -- Iy.FP) ++ (Iy.FPo -- Ix.FP)
  requires Ix.inf[x] == I.inf[x] + Iy.inf[y] * Iy.fm[y][x]
  requires Iy.inf[y] == I.inf[y] + Ix.inf[x] * Ix.fm[x][y]
    // TODO how to instantiate inner forall? If we can, don't need to provide I
    //  requires exists Cxx: Int, Cxy: Int, Cyx: Int, Cyy: Int :: // Capacity values
    //    (forall n in I.FPo :: I.fm[x][n] == Cxx * Ix.fm[x][n] + Cxy * Iy.fm[y][n]
    //     && I.fm[y][n] == Cyy * Iy.fm[y][n] + Cyx * Ix.fm[x][n])
  requires x !in Iy.FPo  // In this case, easier to check new flow map:
  requires (forall n in I.FPo :: I.fm[x][n] == Ix.fm[x][n] + Ix.fm[x][y] * Iy.fm[y][n])
  requires (forall n in I.FPo :: I.fm[y][n] == Iy.fm[y][n] + Iy.fm[y][x] * Ix.fm[x][n])
  ensures intComp(Ix, Iy) == I

procedure lemma_int_comp_unfold(x: Node, Ix: Interface, y: Node, Iy: Interface, I: Interface)
  requires Ix != intUndef && Iy != intUndef && I != intUndef
  requires intComp(Ix, Iy) == I && x != y
  requires Ix.FP == {x} && Iy.FP == {y}
  ensures I.FP == {x, y}
  ensures I.FPo == (Ix.FPo -- Iy.FP) ++ (Iy.FPo -- Ix.FP)
  ensures Ix.inf[x] == I.inf[x] + Iy.inf[y] * Iy.fm[y][x]
  ensures Iy.inf[y] == I.inf[y] + Ix.inf[x] * Ix.fm[x][y]
  ensures exists Cxx: Int, Cxy: Int, Cyx: Int, Cyy: Int :: // Capacity values
    Cxx == Cxy * Iy.fm[y][x] && Cyy == Cyx * Ix.fm[x][y]
    && Cxy == Cxx * Ix.fm[x][y] && Cyx == Cyy * Iy.fm[y][x]
    && (forall n in I.FPo :: I.fm[x][n] == Cxx * Ix.fm[x][n] + Cxy * Iy.fm[y][n]
       && I.fm[y][n] == Cyy * Iy.fm[y][n] + Cyx * Ix.fm[x][n])

procedure no_op(x: Node, I: Interface)
  requires N(x, I) &*& I != intUndef
  ensures N(x, I)
{
  lemma_conc(x, I);
  var y := x.next;
  x.next := y;
  lemma_abs(x, I, I);
  lemma_dirty_N_is_Gr(x, I, I);
  lemma_int_leq_fold(I, I);
  sync(I, I);
  lemma_Gr_is_N(x, I);
}

procedure test_int_comp3(x: Node, Ix: Interface, y: Node, Iy: Interface, z: Node)
  returns (Ixy: Interface)
  requires N(x, Ix) &*& N(y, Iy) &*& z != x &*& x != y;
  requires Ix != intUndef &*& Iy != intUndef // TODO get this from N(x, Ix)
  requires Ix.FP == {x} && Ix.inf[x] == 1 && Ix.FPo == {y, z} && Ix.fm[x][y] == 1 && Ix.fm[x][z] == 1
  requires Iy.FP == {y} && Iy.inf[y] == 2 && Iy.FPo == {z} && Iy.fm[y][z] == 1
  ensures N(x, Ix) &*& N(y, Iy) &*& intComp(Ix, Iy) == Ixy
{
  pure assume Ixy != intUndef && Ixy.FP == {x, y} && Ixy.inf[x] == 1 && Ixy.inf[y] == 1 && Ixy.FPo == {z} && Ixy.fm[x][z] == 2 && Ixy.fm[y][z] == 1;

  pure assume forall I: Interface, n: Node, n1: Node :: (n !in I.FP ==> I.inf[n] == 0 && I.fm[n][n1] == 0) && (n1 !in I.FPo ==> I.fm[n][n1] == 0);
  pure assume forall I: Interface, n: Node :: n !in I.FP || n !in I.FPo;

  lemma_int_comp_fold(x, Ix, y, Iy, Ixy);
}


// Insert node x after node y
procedure insert(x: Node, Ix: Interface, y: Node, I: Interface)
  returns (I1: Interface)
  requires [acc(x)](Ix) &*& Gr(I)
  requires Ix.FP == {x} &*& Ix.inf[x] == 0 &*& Ix.FPo == {}
  requires y in I.FP &*& I.inf[y] == 1 &*& I.FPo == {}
  requires Ix != intUndef &*& I != intUndef
  ensures Gr(I1) &*& intLeq(intComp(Ix, I), I1) == true
    //  TODO properties of intLeq imply these:
    //  ensures x in I1.FP &*& y in I1.FP
    //  ensures I1.inf[y] == 1 &*& I1.FPo == {}
{
   // TODO add as axioms instead:
  pure assume forall I: Interface, n: Node, n1: Node ::
    (n !in I.FP ==> I.inf[n] == 0 && I.fm[n][n1] == 0)
    && (n1 !in I.FPo ==> I.fm[n][n1] == 0);
  pure assume forall I: Interface, I1: Interface, I2: Interface ::
    intComp(I1, I2) == intComp(I2, I1);
  pure assume forall I1: Interface, I2: Interface, I3: Interface ::
    intComp(I1, intComp(I2, I3)) == intComp(intComp(I1, I2), I3);
  pure assume forall I: Interface, I1: Interface, I2: Interface ::
    intComp(I1, I2) == I ==> (I != intUndef && I1 != intUndef && I2 != intUndef);
  // TODO possible unsoundness - ensure this is true when interfaces are created!!
  pure assume forall I: Interface, n: Node :: n !in I.FP || n !in I.FPo;

  var I0 := lemma_comp_sing_int(x, Ix, I);
  // I0 == intComp(Ix, I)

  // TODO why doesn't this work?
  // var Iy, I2 := lemma_decomp(y, I);
  var Iy: Interface, I2: Interface;
  Iy, I2 := lemma_decomp(y, I);
  // [x |-> ?](Ix) &*& N(y, Iy) &*& Gr(I2) &*& I == intComp(Iy, I2)
  lemma_conc(y, Iy);
  var z := y.next;
  // [x |-> ?](Ix) &*& [y |-> z](Iy) &*& Gr(I2)

  x.next := y.next;
  y.next := x;
  // [x |-> z](Ix) &*& [y |-> x](Iy) &*& Gr(I2)

  var Ix1: Interface;    // TODO change grammar to allow assignment?
  pure assume Ix1 != intUndef && Ix1.FP == {x} && Ix1.inf[x] == 1
    && (x.next == null && Ix1.FPo == {}
       || x.next != null && Ix1.FPo == {x.next} && Ix1.fm[x][x.next] == 1);
  lemma_abs(x, Ix, Ix1);
  lemma_dirty_N_is_Gr(x, Ix1, Ix);
  // [Gr(Ix1)](Ix) &*& [y |-> x](Iy) &*& Gr(I2)

  var Iy1: Interface;
  pure assume Iy1 != intUndef && Iy1.FP == {y} && Iy1.inf[y] == 1 && Iy1.FPo == {x}
    && Iy1.fm[y][x] == 1;
  lemma_abs(y, Iy, Iy1);
  lemma_dirty_N_is_Gr(y, Iy1, Iy);
  // [Gr(Ix1)](Ix) &*& [Gr(Iy1)](Iy) &*& Gr(I2)

  // TODO how do we know x != z? Need conditional, (Step), and Gr footprint
  pure assume x != z;

  var Ixy1: Interface;
  pure assume Ixy1 != intUndef && Ixy1.FP == {x, y}
    && Ixy1.inf[x] == 0 && Ixy1.inf[y] == 1
    && (z != null && Ixy1.FPo == {z} && Ixy1.fm[x][z] == 1 && Ixy1.fm[y][z] == 1
       || z == null && Ixy1.FPo == {});
  lemma_int_comp_fold(y, Iy1, x, Ix1, Ixy1);

  var Ixy := lemma_comp(Ix, Ix1, Iy, Iy1);
  // [Gr(Ix1) &*& Gr(Iy1)](Ixy) &*& Gr(I2) &*& Ixy == intComp(Ix, Iy)

  Ixy1 := lemma_dirty_Gr_comp(Ix1, Iy1, Ixy);
  // [Gr(Ixy1)](Ixy) &*& Gr(I2)

  lemma_int_comp_unfold(x, Ix, y, Iy, Ixy);
  lemma_int_comp_unfold(x, Ix1, y, Iy1, Ixy1);
  lemma_int_leq_fold(Ixy, Ixy1);

  sync(Ixy, Ixy1);
  // Gr(Ixy1) &*& Gr(I2)

  I1 := lemma_Gr_comp(Ixy1, I2);
  // Gr(I1) &*& I1 == intComp(Ixy1, I2)

  lemma_int_leq_comp(I0, Ixy, I2, Ixy1, I1);
}
  // I0 == intComp(Ix, I) &*& I == intComp(Iy, I2)
 // Ixy == intComp(Ix, Iy)
 // I1 == intComp(Ixy1, I2)
 // intLeq(Ixy, Ixy1)

 // I0 == intComp(Ixy, I2) ==> intLeq(I0, I1)

 
