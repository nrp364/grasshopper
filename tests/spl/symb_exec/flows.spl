struct Node {
  var next: Node;
}


predicate Gr(i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>) { true }

predicate N(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>) { true }


/** Lemmas */

procedure lemma_N_is_Gr(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>)
  returns ()
  requires N(x, i, f, FP, FPo)
  ensures Gr(i, f, FP, FPo)

procedure lemma_conc(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>)
  returns ()
  requires N(x, i, f, FP, FPo)
  ensures [acc(x) &*& i[x] == 1 &*& (FPo == {} || FPo == {x.next} && f[x][x.next] == 1)](i, f, FP, FPo) &*& FP == {x}

procedure lemma_abs(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>, i1: Map<Node, Int>, f1: Map<Node, Map<Node, Int>>, FP1: Set<Node>, FPo1: Set<Node>)
  returns ()
  requires [acc(x) &*& i1[x] == 1 &*& (FPo1 == {} || FPo1 == {x.next} && f[x][x.next] == 1)](i, f, FP, FPo) &*& FP1 == {x}
  ensures [N(x, i1, f1, FP1, FPo1)](i, f, FP, FPo)
{}

function intLeq(i1: Map<Node, Int>, f1: Map<Node, Map<Node, Int>>, FP1: Set<Node>, FPo1: Set<Node>, i2: Map<Node, Int>, f2: Map<Node, Map<Node, Int>>, FP2: Set<Node>, FPo2: Set<Node>) returns (res: Bool)

procedure sync(i1: Map<Node, Int>, f1: Map<Node, Map<Node, Int>>, FP1: Set<Node>, FPo1: Set<Node>, i2: Map<Node, Int>, f2: Map<Node, Map<Node, Int>>, FP2: Set<Node>, FPo2: Set<Node>)
  returns ()
  requires [Gr(i2, f2, FP2, FPo2)](i1, f1, FP1, FPo1) &*& intLeq(i1, f1, FP1, FPo1, i2, f2, FP2, FPo2)
  ensures Gr(i2, f2, FP2, FPo2)


procedure test(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>)
  returns (f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>)
  requires N(x, i, f, FP, FPo)
  ensures N(x, i, f1, FP, FPo1)
{
  lemma_conc(x, i, f, FP, FPo);
  var y := x.next;
  x.next := y;
  //  var f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>;
  //  pure assume f1 == TODO && FPo1 == TODO;
  lemma_abs(x, i, f, FP, FPo, i, f, FP, FPo);
  //  sync();
}
