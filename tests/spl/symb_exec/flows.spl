struct Node {
  var next: Node;
}

datatype Interface =
  int(inf: Map<Node, Int>,
      fm: Map<Node, Map<Node, Int>>,
      FP: Set<Node>,
      FPo: Set<Node>);

predicate Gr(I: Interface) { true }

predicate N(x: Node, I: Interface) { true }


/** Lemmas */

procedure lemma_N_is_Gr(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures Gr(I)

procedure lemma_dirty_N_is_Gr(x: Node, I1: Interface, I2: Interface)
  returns ()
  requires [N(x, I1)](I2)
  ensures [Gr(I1)](I2)

procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures [acc(x) &*& I.inf[x] == 1 &*& (I.FPo == {} || I.FPo == {x.next} && I.fm[x][x.next] == 1)](I) &*& I.FP == {x}

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires [acc(x) &*& I1.inf[x] == 1 &*& (I1.FPo == {} || I1.FPo == {x.next} && I1.fm[x][x.next] == 1)](I) &*& I1.FP == {x}
  ensures [N(x, I1)](I)
{}

function intLeq(I1: Interface, I2: Interface) returns (res: Bool)
  ensures forall I3: Interface :: intLeq(I3, I3)

procedure sync(I1: Interface, I2: Interface)
  returns ()
  requires [Gr(I2)](I1) &*& intLeq(I1, I2) == true
  ensures Gr(I2)


procedure test(x: Node, I: Interface)
  returns (f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>)
  requires N(x, I)
  ensures N(x, I)
{
  lemma_conc(x, I);
  var y := x.next;
  x.next := y;
  //  var f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>;
  //  pure assume f1 == TODO && FPo1 == TODO;
  lemma_abs(x, I, I);
  lemma_dirty_N_is_Gr(x, I, I);
  sync(I, I);
}

// TODO recognize pure atoms like intLeq() - or write == true
// TODO bind vars before calling SMT solver
