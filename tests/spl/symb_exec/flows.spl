struct Node {
  var next: Node;
}


predicate gamma(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FPo: Set<Node>) {
  acc(x) &*& x.i == 1 &*& (FPo == {} || FPo == {x.next}/* && x.next.(x.f) == 1*/)
}

predicate Gr(i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>) { true }

predicate N(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>) { true }


procedure lemma_conc(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>)
  returns ()
  requires N(x, i, f, FP, FPo)
  ensures Dirty(i, f, FP, FPo, gamma(x, i, f, FPo)) && FP == {x}


procedure test(x: Node, i: Map<Node, Int>, f: Map<Node, Map<Node, Int>>, FP: Set<Node>, FPo: Set<Node>) returns (f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>)
  requires N(x, i, f, FP, FPo)
  ensures N(x, i, f1, FP, FPo1)
{
  lemma_conc(x, i, f, FP, FPo);
  x.next := null;
  lemma_abs(x, i, f1, FP, FPo1);
  sync()
}
