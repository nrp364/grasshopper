struct Node {
  var next: Node;
}

datatype Interface =
  int(inf: Map<Node, Int>,
      fm: Map<Node, Map<Node, Int>>,
      FP: Set<Node>,
      FPo: Set<Node>);

predicate Gr(I: Interface)

predicate N(x: Node, I: Interface)

function intComp(I: Interface, I1: Interface, I2: Interface) returns (res: Bool)

/** Lemmas */

// Sufficient condition for intComp(I, Ix, Iy), when there's no edge y -> x
procedure lemma_int_comp(x: Node, Ix: Interface, y: Node, Iy: Interface, I: Interface)
  requires Ix.FP == {x} && Iy.FP == {y} //TODO && x != y
  requires I.FP == {x, y}
  requires I.FPo == (Ix.FPo -- Iy.FP) ++ (Iy.FPo -- Ix.FP) && x !in Iy.FPo
  requires Ix.inf[x] == I.inf[x]
  requires Iy.inf[y] == I.inf[y] + Ix.inf[x] * Ix.fm[x][y]
  requires (forall n in I.FPo :: I.fm[x][n] == Ix.fm[x][n] + Ix.fm[x][y] * Iy.fm[y][n])
  requires (forall n in I.FPo :: I.fm[y][n] == Iy.fm[y][n])
  ensures intComp(I, Ix, Iy) == true

procedure lemma_N_is_Gr(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures Gr(I)

procedure lemma_dirty_N_is_Gr(x: Node, I1: Interface, I2: Interface)
  requires [N(x, I1)](I2)
  ensures [Gr(I1)](I2)

procedure lemma_Gr_is_N(x: Node, I: Interface)
  returns ()
  requires Gr(I) &*& I.FP == {x}
  ensures N(x, I)

procedure lemma_comp(I: Interface, I1: Interface, I2: Interface)
  requires Gr(I1) &*& Gr(I2) &*& intComp(I, I1, I2) == true
  ensures Gr(I)

procedure lemma_dirty_comp(x: Node, Ix1: Interface, y: Node, Iy1: Interface, I: Interface, I1: Interface)
  requires [N(x, Ix1) &*& N(y, Iy1)](I) &*& intComp(I1, Ix1, Iy1) == true
  ensures [Gr(I1)](I)

procedure lemma_decomp(x: Node, I: Interface)
  returns (I1: Interface, I2: Interface)
  requires Gr(I) &*& x in I.FP
    ensures N(x, I1) &*& Gr(I2) &*& intComp(I, I1, I2) == true

procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures [acc(x) &*& I.inf[x] == 1 &*& (x.next == null && I.FPo == {} || x.next != null && I.FPo == {x.next} && I.fm[x][x.next] == 1)](I) &*& I.FP == {x}

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires [acc(x) &*& I1.inf[x] == 1 &*& (x.next == null && I1.FPo == {} || x.next != null && I1.FPo == {x.next} && I1.fm[x][x.next] == 1)](I) &*& I1.FP == {x}
  ensures [N(x, I1)](I)
{}

procedure lemma_dirty_join(x: Node, Ix: Interface, Ix1: Interface, y: Node, Iy: Interface, Iy1: Interface, I: Interface)
  requires [N(x, Ix1)](Ix) &*& [N(y, Iy1)](Iy) &*& intComp(I, Ix, Iy) == true
  ensures [N(x, Ix1) &*& N(y, Iy1)](I)

procedure sync(I1: Interface, I2: Interface)
  returns ()
  requires [Gr(I2)](I1)
  requires I1.FP == I2.FP && I1.FPo == I2.FPo
  requires forall n in I1.FP :: I1.inf[n] == I2.inf[n]
  requires forall n in I1.FP, o in I1.FPo :: I1.inf[n] != 0 ==> I1.fm[n][o] == I2.fm[n][o]
  ensures Gr(I2)


procedure no_op(x: Node, I: Interface)
  requires N(x, I)
  ensures N(x, I)
{
  lemma_conc(x, I);
  var y := x.next;
  x.next := y;
  lemma_abs(x, I, I);
  lemma_dirty_N_is_Gr(x, I, I);
  sync(I, I);
  lemma_Gr_is_N(x, I);
}

procedure test_int_comp(x: Node, Ix: Interface, y: Node, Iy: Interface)
  returns (Ixy: Interface)
  requires N(x, Ix) &*& N(y, Iy)
  ensures Gr(Ixy) &*& intComp(Ixy, Ix, Iy) == true
{
  pure assume Ix.FP == {x} && Ix.inf[x] == 1 && Ix.FPo == {};
  pure assume Iy.FP == {y} && Iy.inf[y] == 1 && Iy.FPo == {};
  pure assume Ixy.FP == {x, y} && Ixy.inf[x] == 1 && Ixy.inf[y] == 1 && Ixy.FPo == {};

  pure assume forall I: Interface, n: Node, n1: Node :: (n !in I.FP ==> I.inf[n] == 0 && I.fm[n][n1] == 0) && (n1 !in I.FPo ==> I.fm[n][n1] == 0);

  lemma_int_comp(x, Ix, y, Iy, Ixy);
  lemma_N_is_Gr(x, Ix);
  lemma_N_is_Gr(y, Iy);
  lemma_comp(Ixy, Ix, Iy);
}

// Insert node x after node y
procedure insert(x: Node, Ix: Interface, y: Node, I: Interface)
  returns (I1: Interface)
  requires [acc(x)](Ix) &*& Gr(I)
  requires Ix.FP == {x} &*& Ix.inf[x] == 0 &*& Ix.FPo == {} &*& y in I.FP &*& I.inf[y] == 1
  ensures Gr(I1) &*& x in I1.FP &*& y in I1.FP &*& I1.inf[y] == 1
{
  var Iy: Interface, I2: Interface;
  Iy, I2 := lemma_decomp(y, I);
  // [x |-> ?](Ix) &*& N(y, Iy) &*& Gr(I2)
  lemma_conc(y, Iy);
  var z := y.next;
  // [x |-> ?](Ix) &*& [y |-> z](Iy) &*& Gr(I2)

  x.next := y.next;
  y.next := x;
  // [x |-> z](Ix) &*& [y |-> x](Iy) &*& Gr(I2)

  var Ix1: Interface;    // TODO change grammar to allow assignment
  pure assume Ix1.FP == {x} && Ix1.inf[x] == 1 && (x.next == null && Ix1.FPo == {} || x.next != null && Ix1.FPo == {x.next} && Ix1.fm[x][x.next] == 1);
  lemma_abs(x, Ix, Ix1);
  // [N(x, Ix1)](Ix) &*& [y |-> x](Iy) &*& Gr(I2)

  var Iy1: Interface;
  pure assume Iy1.FP == {y} && Iy1.inf[y] == 1 && Iy1.FPo == {x} && Iy1.fm[y][x] == 1;
  lemma_abs(y, Iy, Iy1);
  // [N(x, Ix1)](Ix) &*& [N(y, Iy1)](Iy) &*& Gr(I2)

  var Ixy: Interface;
  pure assume Ixy.FP == {x, y} && Ixy.inf[x] == 0 && Ixy.inf[y] == 1 && (z != null && Ixy.FPo == {z} && Ixy.fm[x][z] == 0 && Ixy.fm[y][z] == 1 || z == null && Ixy.FPo == {});
  // TODO add as an axiom instead
  pure assume forall I: Interface, n: Node, n1: Node :: (n !in I.FP ==> I.inf[n] == 0 && I.fm[n][n1] == 0) && (n1 !in I.FPo ==> I.fm[n][n1] == 0);
  pure assume forall I: Interface, I1: Interface, I2: Interface :: intComp(I, I1, I2) == intComp(I, I2, I1);
  // TODO how do we know x != z?
  pure assume x != z && y != z;
  lemma_int_comp(y, Iy, x, Ix, Ixy);
  lemma_dirty_join(x, Ix, Ix1, y, Iy, Iy1, Ixy);
  // [N(x, Ix1) &*& N(y, Iy1)](Ixy) &*& Gr(I2)

  var Ixy1: Interface;
  pure assume Ixy1.FP == {x, y} && Ixy1.inf[x] == 0 && Ixy1.inf[y] == 1 && (z != null && Ixy1.FPo == {z} && Ixy1.fm[x][z] == 1 && Ixy1.fm[y][z] == 1 || z == null && Ixy1.FPo == {});
  lemma_int_comp(y, Iy1, x, Ix1, Ixy1);
  lemma_dirty_comp(x, Ix1, y, Iy1, Ixy, Ixy1);
  // [Gr(Ixy1)](Ixy) &*& Gr(I2)

  sync(Ixy, Ixy1);
  assert false;
  // TODO intLeq and its consequences
}
// TODO need some way to lift lemmas to use them inside dirty regions?
// TODO recognize pure atoms like intComp() - instead of writing intComp() == true
