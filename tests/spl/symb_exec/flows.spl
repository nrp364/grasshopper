struct Node {
  var next: Node;
}

datatype Interface =
  int(inf: Map<Node, Int>,
      fm: Map<Node, Map<Node, Int>>,
      FP: Set<Node>,
      FPo: Set<Node>);

predicate Gr(I: Interface) { true }

predicate N(x: Node, I: Interface) { true }


/** Lemmas */

procedure lemma_N_is_Gr(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures Gr(I)

procedure lemma_dirty_N_is_Gr(x: Node, I1: Interface, I2: Interface)
  returns ()
  requires [N(x, I1)](I2)
  ensures [Gr(I1)](I2)

procedure lemma_conc(x: Node, I: Interface)
  returns ()
  requires N(x, I)
  ensures [acc(x) &*& I.inf[x] == 1 &*& (I.FPo == {} || I.FPo == {x.next} && I.fm[x][x.next] == 1)](I) &*& I.FP == {x}

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  returns ()
  requires [acc(x) &*& I1.inf[x] == 1 &*& (I1.FPo == {} || I1.FPo == {x.next} && I1.fm[x][x.next] == 1)](I) &*& I1.FP == {x}
  ensures [N(x, I1)](I)
{}

procedure sync(I1: Interface, I2: Interface)
  returns ()
  requires [Gr(I2)](I1)
  requires I1.FP == I2.FP && I1.FPo == I2.FPo
  requires forall n in I1.FP :: I1.inf[n] == I2.inf[n]
  requires forall n in I1.FP, o in I1.FPo :: I1.inf[n] != 0 ==> I1.fm[n][o] == I2.fm[n][o]
  ensures Gr(I2)


procedure test(x: Node, I: Interface)
  returns (f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>)
  requires N(x, I)
  ensures N(x, I)
{
  lemma_conc(x, I);
  var y := x.next;
  x.next := y;
  //  var f1: Map<Node, Map<Node, Int>>, FPo1: Set<Node>;
  //  pure assume f1 == TODO && FPo1 == TODO;
  lemma_abs(x, I, I);
  lemma_dirty_N_is_Gr(x, I, I);
  sync(I, I);
}

// TODO look into why sync precondition is becoming true
// TODO where do we compute composition of flow maps for multiple nodes?
  // need some way to lift lemmas to use them inside dirty regions?
// TODO recognize pure atoms like intLeq() - instead of writing intLeq() == true
