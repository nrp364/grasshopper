include "b-link.spl";


procedure half_split(c: Node, Ic: Interface, x: Node, Ix: Interface, Icx: Interface)
  returns (Ic1: Interface, Ix1: Interface, Icx1: Interface)
  requires hrep(c, Ic) &*& hrepSpatial(x) &*& emptyInt(x, Ix)
  requires intValid(Ic) == true && intValid(Ix) == true
  requires intComp(Ic, Ix) == Icx && intValid(Icx) == true
  requires x.keys.length == 2*B && x.ptrs.length == 2*B
  requires c.len == 2 * B - 1
  // Follows from x being allocated freshly
  requires x !in Ic.FPo && c.next != x && (forall i: Int :: 0 <= i <= c.len ==> x != c.ptrs[i])

  ensures hrep(c, Ic1) &*& hrep(x, Ix1)
  ensures intValid(Ic1) == true && intValid(Ix1) == true
  ensures intComp(Ic1, Ix1) == Icx1 && intEq(Icx, Icx1) == true
  ensures Icx.na.contents == Icx1.na.contents
{
  // Save old values of c
  var cnext, ckeys, cptrs, clen, crangeLb, crangeUb :=
    c.next, c.keys.map, c.ptrs.map, c.len, c.rangeLb, c.rangeUb;

  var m := (c.len + 1) / 2;
  var k := c.keys[m - 1];

  if (c.ptrs[0] == null) {  // Leaf
    arr_copy(c.keys, x.keys, m, 0, c.len - m + 1);
    x.ptrs[0] := null;
    x.len := m - 1;
    x.next := c.next;
    c.len := m;
    c.next := x;
    x.rangeUb := c.rangeUb;
    pure assume false;
  } else {  // Internal node
    lemma_int_stable(c, 2*B);
    pure assert Ic == int_ind(c, cnext, ckeys, cptrs, clen, crangeLb, crangeUb, 2*B);
    
    arr_copy(c.keys, x.keys, m, 0, c.len - m + 1);
    arr_copy_node(c.ptrs, x.ptrs, m, 0, c.len - m + 1);
    x.len := m - 1;
    c.len := m - 1;
    x.next := c.next;
    c.next := x;
    x.rangeLb := c.keys[c.len];
    x.rangeUb := c.rangeUb;

    Ic1 := compute_int(c);
    Ix1 := compute_int(x);

    pure assert Ix.na == nd({}, inrfnC({n: Node :: {}}, {x}), {});

    Ic, Ic1, Ix1, Icx, Icx1 := lemma_Icx1_eq_Icx(c, cnext, ckeys, cptrs, clen,
      crangeLb, crangeUb, x, Ix, 2*B-1);
    lemma_int_stable(c, 2*B-1);
    lemma_int_stable(x, B-1);

    // TODO have an ndJoin function and add this to definition of intComp
    pure assume Icx.na.contents == Ic.na.contents ++ Ix.na.contents
    && Icx1.na.contents == Ic1.na.contents ++ Ix1.na.contents;
  }
}

// The fields cnext etc are the old values
// TODO
lemma lemma_Icx1_eq_Icx(c: Node, cnext: Node, ckeys: Map<Int, K>, cptrs: Map<Int, Node>, clen: Int,
                        crangeLb: K, crangeUb: K, x: Node, Ix: Interface, i: Int)
  returns (Ic: Interface, Ic1: Interface, Ix1: Interface, Icx: Interface, Icx1: Interface)
  requires emptyInt(x, Ix) // TODO doesn't work even though the assert above works
  requires intValid(Ix) == true
  requires heapGood(c, cnext, ckeys, cptrs, clen, crangeLb, crangeUb)
  requires heapGood(c, c.next, c.keys, c.ptrs, c.len, c.rangeLb, c.rangeUb)
  requires heapGood(x, x.next, x.keys, x.ptrs, x.len, x.rangeLb, x.rangeUb)
  requires hrepSpatial(c) &*& hrepSpatial(x)
  requires c.ptrs[0] != null && x.ptrs[0] != null && cptrs[0] != null

  requires cnext != x && (forall i: Int :: 0 <= i <= clen ==> x != cptrs[i]) && clen == 2*B - 1
  requires c.next == x && c.rangeLb == crangeLb && c.rangeUb == crangeUb && c.len == B - 1
  requires x.next == cnext && x.rangeLb == c.keys[c.len] && x.rangeUb == crangeUb && x.len == B - 1
  requires forall i: Int :: 0 <= i <= c.len ==> c.keys[i] == ckeys[i]
  requires forall i: Int :: 0 <= i <= c.len ==> c.ptrs[i] == cptrs[i]
  requires forall i: Int :: 0 <= i <= x.len ==> x.keys[i] == ckeys[i + B]
    @(matching x.keys[i] yields ckeys[i + B])
  requires forall i: Int :: 0 <= i <= x.len ==> x.ptrs[i] == cptrs[i + B]
    @(matching x.ptrs[i] yields cptrs[i + B])

  ensures hrepSpatial(c) &*& hrepSpatial(x) &*& unchanged(c) &*& unchanged(x)

  ensures Ic == int_ind(c, cnext, ckeys, cptrs, clen, crangeLb, crangeUb, i)
  ensures Ic1 == int_ind(c, c.next, c.keys.map, c.ptrs.map, c.len, c.rangeLb, c.rangeUb, i)
  ensures Ix1 == int_ind(x, x.next, x.keys.map, x.ptrs.map, x.len, x.rangeLb, x.rangeUb, i - B)
  ensures Icx == intComp(Ic, Ix) && Icx != intUndef
  ensures Icx1 == intComp(Ic1, Ix1) && Icx1 != intUndef

  ensures x !in Ic.FPo && c !in Ix1.FPo
  ensures Ic.FPo == Ic1.FPo ++ Ix1.FPo
  ensures (forall x: Node :: domEq(Icx.inf[x], Icx1.inf[x]))
  ensures (forall x: Node, y: Node ::
    domEq(domMult(Icx.inf[x], Icx.fm[x][y]), domMult(Icx1.inf[x], Icx1.fm[x][y])))
{
  Ic := lemma_int_ind_is_valid(c, cnext, ckeys, cptrs, clen, crangeLb, crangeUb, i);
  Ic1 := lemma_int_ind_is_valid(c, c.next, c.keys.map, c.ptrs.map, c.len, c.rangeLb, c.rangeUb, i);
  Ix1 := lemma_int_ind_is_valid(x, x.next, x.keys.map, x.ptrs.map, x.len, x.rangeLb, x.rangeUb, i - B);

  if (i < 0) {
    pure assert domLeq(domMult(Ix.inf[x], Ix.fm[x][y]), Iy.inf[y]);  // This fails
    // The next two asserts help manually unfold domMult
    pure assert
      (forall k: K :: Ic.inf[c].ks[k] * Ic.fm[c][x].ks[k] == domMult(Ic.inf[c], Ic.fm[c][x]).ks[k])
      && (forall k: K :: domMult(Ic.inf[c], Ic.fm[c][x]).ks[k] <= Ix.inf[x].ks[k])
      && (forall k: K :: Ic.inf[c].ir[k] * Ic.fm[c][x].ir[k] <= domMult(Ic.inf[c], Ic.fm[c][x]).ir[k])
      && (forall k: K :: domMult(Ic.inf[c], Ic.fm[c][x]).ir[k] <= Ix.inf[x].ir[k]);
    pure assert
      (forall k: K :: Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k] == domMult(Ic1.inf[c], Ic1.fm[c][x]).ks[k])
      && (forall k: K :: domMult(Ic1.inf[c], Ic1.fm[c][x]).ks[k] <= Ix1.inf[x].ks[k])
      && (forall k: K :: Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k] <= domMult(Ic1.inf[c], Ic1.fm[c][x]).ir[k])
      && (forall k: K :: domMult(Ic1.inf[c], Ic1.fm[c][x]).ir[k] <= Ix1.inf[x].ir[k]);
    
    Icx := lemma_int_comp_fold(c, Ic, x, Ix);
    Icx1 := lemma_int_comp_fold(c, Ic1, x, Ix1);
    lemma_int_comp_unfold(c, Ic, x, Ix, Icx);
    lemma_int_comp_unfold(c, Ic1, x, Ix1, Icx1);

    pure assert (forall x: Node :: domEq(Icx.inf[x], Icx1.inf[x]));  // This fails too

    pure assert (forall y: Node, k: K :: y == c || y == x || (Icx.inf[y].ks[k] == 0 && Icx.inf[y].ir[k] == 0));
    pure assert (forall y: Node, k: K :: y == c || y == x || (Icx1.inf[y].ks[k] == 0 && Icx1.inf[y].ir[k] == 0));
         
    pure assert (forall x: Node, k: K :: Icx.inf[x].ks[k] == Icx1.inf[x].ks[k]
      && Icx.inf[x].ir[k] == Icx1.inf[x].ir[k]);
    
    return Ic, Ic1, Ix1, Icx, Icx1;
  } else {
    //  if (i >= 0) {
    // ****************************************
    pure assume false;  // TODO REMOVE
    // ****************************************
    var IIc: Interface, IIc1: Interface, IIx1: Interface, IIcx: Interface, IIcx1: Interface;
    IIc, IIc1, IIx1, IIcx, IIcx1 := lemma_Icx1_eq_Icx(c, cnext, ckeys, cptrs, clen,
      crangeLb, crangeUb, x, Ix, i - 1);

    pure assert c !in Ix1.FPo;
    pure assert x !in Ic.FPo;
    lemma_int_valid_unfold(c, Ic);
    lemma_int_valid_unfold(x, Ix);
    lemma_int_valid_unfold(c, Ic1);
    lemma_int_valid_unfold(x, Ix1);

    pure assume domLeq(domMult(Ic.inf[c], Ic.fm[c][x]), Ix.inf[x]) == true;  // TODO
    pure assert (forall k: K :: Ic1.inf[c].ks[k] * Ic1.fm[c][x].ks[k] <= Ix1.inf[x].ks[k])
      && (forall k: K :: Ic1.inf[c].ir[k] * Ic1.fm[c][x].ir[k] <= Ix1.inf[x].ir[k]);
    pure assume domLeq(domMult(Ic1.inf[c], Ic1.fm[c][x]), Ix1.inf[x]) == true;  // TODO

    Icx := lemma_int_comp_fold(c, Ic, x, Ix);
    Icx1 := lemma_int_comp_fold(c, Ic1, x, Ix1);
    lemma_int_comp_unfold(c, Ic, x, Ix, Icx);
    lemma_int_comp_unfold(c, Ic1, x, Ix1, Icx1);

    //  pure assert forall k: K :: Ix.inf[x].ks[k] == Icx.inf[x].ks[k] + (Ic.inf[c].ks[k] * Ic.fm[c][x].ks[k]);
    // TODO: try using domMinus to define this, and define domEq with custom triggers?
    pure assume forall x: Node :: domEq(Icx.inf[x], Icx1.inf[x]);
    pure assume forall x: Node, y: Node ::
      domEq(domMult(Icx.inf[x], Icx.fm[x][y]), domMult(Icx1.inf[x], Icx1.fm[x][y]));
    
    return Ic, Ic1, Ix1, Icx, Icx1;
  }
}
