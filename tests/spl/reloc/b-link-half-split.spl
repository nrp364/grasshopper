include "b-link.spl";

options "-symbexec"


procedure half_split(c: Node, Ic: Interface, x: Node, Ix: Interface, Icx: Interface)
  returns (Ic1: Interface, Ix1: Interface, Icx1: Interface)
  requires hrep(c, Ic) &*& hrepSpatial(x)
  requires Ix.FP == {x} && domEq(Ix.inf[x], domZero()) == true && Ix.FPo == {}
  requires intValid(Ic) == true && intValid(Ix) == true
  requires intComp(Ic, Ix) == Icx && intValid(Icx) == true
  requires x.keys.length == 2*B && x.ptrs.length == 2*B
  requires c.len == 2 * B - 1
  requires x !in Ic.FPo

  ensures hrep(c, Ic1) &*& hrep(x, Ix1)
  ensures intValid(Ic1) == true && intValid(Ix1) == true
  ensures intComp(Ic1, Ix1) == Icx1 && intEq(Icx, Icx1) == true
  ensures Icx.na.contents == Icx1.na.contents
{
  var m := (c.len + 1) / 2;
  var k := c.keys[m - 1];

  if (c.ptrs[0] == null) {  // Leaf
    arr_copy(c.keys, x.keys, m, 0, c.len - m + 1);
    x.ptrs[0] := null;
    x.len := m - 1;
    x.next := c.next;
    c.len := m;
    c.next := x;

    lemma_int_valid_unfold(c, Ic);
    
    // c's new interface
    var cfm := { n: Node :: { n1: Node :: domZero() } };
    cfm := cfm[c := cfm[c][x := fd({ k: K :: le(c.keys[c.len], k) ? 1 : 0 },
                                   { k: K :: le(c.keys[c.len], k) ? 1 : 0 })]];
    Ic1 := int(Ic.inf, nd(set_of_map(c.keys.map, 0, c.len), Ic.na.inr), cfm, {c}, {x});

    // TODO things to prove
    // Should follow from definition of Ic1:
    pure assume forall k: K :: le(c.keys[c.len], k) ==> Ic1.fm[c][c.next].ks[k] == 1;
    pure assume forall k: K :: !le(c.keys[c.len], k) ==> Ic1.fm[c][c.next].ks[k] == 0;
    // Prove by induction on keys and definition of outset
    pure assume forall k: K :: k in outset(c, Ic.fm) ==> k in outset(c, Ic1.fm);
    // Prove by induction using arr_copy definition:
    pure assume forall k: K :: k in set_of_map(c.keys.map, 0, c.len)
    ==> k in Ic.na.contents // == set_of_map(old(c.keys.map), 0, old(c.len))
         @(matching k in Ic1.na.contents yields Ic.inf[c].ks[k]);
    // Prove by induction using set_of_map definition
    //    pure assume forall k: K :: k in Ic1.na.contents ==> le(x.keys[0], k);
    pure assume forall k: K :: k in Ic1.na.contents ==> lt(k, c.keys[c.len]);

    lemma_int_valid_fold(c, Ic1);
    assert hrepSpatial(x) &*& hrep(c, Ic1);
    

    // x's new interface
    var xkc := { k: K :: le(x.keys[0], k) && Ic.inf[c].ks[k] >= 1 ? 1 : 0 };
    var xir := { k: K :: 0 };
    var xinf := { n: Node :: n == x ? fd(xkc, xir) : domZero() };
    var xfpo: Set<Node>;
    var xfm := { n: Node :: { n1: Node :: domZero() } };
    if (x.next == null) {
      xfpo := {};
    } else {
      xfm := xfm[x := xfm[x][x.next := fd({ k: K :: le(x.keys[x.len], k) ? 1 : 0 },
                                          { k: K :: le(c.keys[c.len], k) ? 1 : 0 })]];
      xfpo := {x.next};
    }
    var xinrSet: Set<K> := { k: K :: xinf[x].ks[k] >= 1 || xinf[x].ir[k] >= 1 };
    var xi := inrfnC({ n: Node :: n == x ? xinrSet : {} }, {x});
    Ix1 := int(xinf, nd(set_of_map(x.keys.map, 0, x.len), xi), xfm, {x}, xfpo);

    // TODO things to prove
    // Should follow from definition of Ix1:
    pure assume domLeq(domZero(), Ix1.inf[x]);
    pure assume forall k: K :: le(x.keys[0], k) && Ic.inf[c].ks[k] >= 1 ==> Ix1.inf[x].ks[k] >= 1;
    pure assume forall k: K :: x.next != null && le(x.keys[x.len], k) ==> Ix1.fm[x][x.next].ks[k] == 1;
    pure assume forall k: K :: x.next != null && !le(x.keys[x.len], k) ==> Ix1.fm[x][x.next].ks[k] == 0;
    pure assume forall k: K :: x.next != null && le(x.keys[x.len], k) ==> Ix1.fm[x][x.next].ir[k] == 1;
    pure assume forall k: K :: x.next != null && !le(x.keys[x.len], k) ==> Ix1.fm[x][x.next].ir[k] == 0;
    // Prove by induction using arr_copy definition:
    pure assume forall k: K :: k in set_of_map(x.keys.map, 0, x.len)
      ==> k in Ic.na.contents // == set_of_map(c.keys.map, 0, old(c.len))
         @(matching k in Ix1.na.contents yields Ic.inf[c].ks[k]);
    // Prove by induction using set_of_map definition
    pure assume forall k: K :: k in Ix1.na.contents ==> le(x.keys[0], k);
    pure assume forall k: K :: k in Ix1.na.contents ==> lt(k, x.keys[x.len]);

    lemma_int_valid_fold(x, Ix1);
    assert hrepSpatial(c) &*& hrep(x, Ix1);


    pure assume false;

    
  } else {  // Internal node
    arr_copy(c.keys, x.keys, m, 0, c.len - m + 1);
    arr_copy_node(c.ptrs, x.ptrs, m, 0, c.len - m + 1);
    x.len := m - 1;
    c.len := m - 1;
    pure assume false;
  }
}
