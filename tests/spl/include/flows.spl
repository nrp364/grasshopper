/* -- Lemma library for flows. Independent of Flow domain. -- */


datatype Interface =
  int(inf: Map<Node, FlowDom>,
      na: NodeDom,
      fm: Map<Node, Map<Node, FlowDom>>,
      FP: Set<Node>,
      FPo: Set<Node>)
  | intUndef; // All interfaces with > 1 inflow are undefined

predicate Gr(I: Interface)

define N(x, I) { Gr(I) &*& I.FP == {x} };


// A functional semantics for interface composition
function intComp(I1: Interface, I2: Interface) returns (I: Interface)
  ensures I.FP == I1.FP ++ I2.FP
  ensures I.FPo == (I1.FPo -- I2.FP) ++ (I2.FPo -- I1.FP)

// Interface contextual extension, encoded as a function
function intLeq(I1: Interface, I2: Interface) returns (res: Bool)

// Encoding of well defined interfaces
function intValid(I: Interface) returns (res: Bool)


// Associativity, commutativity of intComp
axiom forall I1: Interface, I2: Interface ::
  intComp(I1, I2) == intComp(I2, I1) @(matching intComp(I1, I2) yields intComp(I2, I1));
axiom forall I1: Interface, I2: Interface, I3: Interface ::
  intComp(I1, intComp(I2, I3)) == intComp(intComp(I1, I2), I3);

// Composition of undef with anything is undef
axiom forall I1: Interface, I2: Interface ::
  intComp(I1, I2) != intUndef ==> (I1 != intUndef && I2 != intUndef);

// Valid interfaces are not undefined
axiom forall I: Interface :: intValid(I) ==> I != intUndef;

axiom forall I1: Interface, I2: Interface ::
  intValid(I1) && intValid(I2) && intComp(I1, I2) != intUndef ==> intValid(intComp(I1, I2));

axiom forall I1: Interface, I2: Interface ::
  (! intValid(I1) || ! intValid(I2)) ==> intComp(I1, I2) == intUndef;

// Note: we assume that Gr(I) ==> intValid(I) in the following lemmas (TODO automate?)

// Sufficient condition for intComp(I, Ix, Iy), when no edge from y to x
lemma lemma_int_comp_fold(x: Node, Ix: Interface, y: Node, Iy: Interface, I: Interface)
  requires intValid(Ix) == true && intValid(Iy) == true && intValid(I) == true
  requires Ix.FP == {x} && Iy.FP == {y} && x != y && I.FP == {x, y}
  requires I.FPo == (Ix.FPo -- Iy.FP) ++ (Iy.FPo -- Ix.FP)
  requires Ix.inf[x] == domPlus(I.inf[x], domMult(Iy.inf[y], Iy.fm[y][x]))
  requires Iy.inf[y] == domPlus(I.inf[y], domMult(Ix.inf[x], Ix.fm[x][y]))
  requires x !in Iy.FPo  // In this case, easier to check new flow map:
  requires (forall n in I.FPo ::
            I.fm[x][n] == domPlus(Ix.fm[x][n], domMult(Ix.fm[x][y], Iy.fm[y][n])))
  requires (forall n in I.FPo ::
            I.fm[y][n] == domPlus(Iy.fm[y][n], domMult(Iy.fm[y][x], Ix.fm[x][n])))
  ensures intComp(Ix, Iy) == I

lemma lemma_int_comp_unfold(x: Node, Ix: Interface, y: Node, Iy: Interface, I: Interface)
  requires Ix != intUndef && Iy != intUndef && I != intUndef
  requires intComp(Ix, Iy) == I && x != y
  requires Ix.FP == {x} && Iy.FP == {y}
  ensures I.FP == {x, y}
  ensures I.FPo == (Ix.FPo -- Iy.FP) ++ (Iy.FPo -- Ix.FP)
  ensures Ix.inf[x] == domPlus(I.inf[x], domMult(Iy.inf[y], Iy.fm[y][x]))
  ensures Iy.inf[y] == domPlus(I.inf[y], domMult(Ix.inf[x], Ix.fm[x][y]))
  ensures exists Cxx: FlowDom, Cxy: FlowDom, Cyx: FlowDom, Cyy: FlowDom ::
    Cxx == domMult(Cxy, Iy.fm[y][x]) && Cyy == domMult(Cyx, Ix.fm[x][y])
    && Cxy == domMult(Cxx, Ix.fm[x][y]) && Cyx == domMult(Cyy, Iy.fm[y][x])
    && (forall n in I.FPo ::
       I.fm[x][n] == domPlus(domMult(Cxx, Ix.fm[x][n]), domMult(Cxy, Iy.fm[y][n]))
       && I.fm[y][n] == domPlus(domMult(Cyy, Iy.fm[y][n]), domMult(Cyx, Ix.fm[x][n]))
       @(matching n yields I.fm[x][n]) @(matching n yields I.fm[y][n])
       @(matching n yields Ix.fm[x][n]) @(matching n yields Iy.fm[y][n])
       @(matching Ix.fm[x][n], Iy.fm[y][n]
         yields domPlus(domMult(Cxx, Ix.fm[x][n]), domMult(Cxy, Iy.fm[y][n])))
       @(matching Ix.fm[x][n], Iy.fm[y][n]
         yields domPlus(domMult(Cyy, Iy.fm[y][n]), domMult(Cyx, Ix.fm[x][n])))
       )
 // TODO Ask Thomas why these aren't automatically generated
 // Also about conservative term gen for Read terms?

lemma lemma_int_valid_unfold(I: Interface)
  requires intValid(I) == true
  ensures forall n: Node, n1: Node ::
    (n !in I.FP ==> I.inf[n] == domZero() && I.fm[n][n1] == domZero())
    && (n1 !in I.FPo ==> I.fm[n][n1] == domZero())
  ensures forall n: Node :: n !in I.FP || n !in I.FPo

lemma lemma_int_valid_fold(I: Interface)
  requires I != intUndef // TODO why? See test_valid2
  requires forall n: Node, n1: Node ::
    (n !in I.FP ==> I.inf[n] == domZero() && I.fm[n][n1] == domZero())
    && (n1 !in I.FPo ==> I.fm[n][n1] == domZero())
  requires forall n: Node :: n !in I.FP || n !in I.FPo
  ensures intValid(I) == true


lemma lemma_Gr_comp(Ix: Interface, Iy: Interface)
  returns (I: Interface)
  requires Gr(Ix) &*& Gr(Iy)
  ensures Gr(I) &*& intComp(Ix, Iy) == I &*& I != intUndef

lemma lemma_Gr_comp_int(Ix: Interface, Iy: Interface)
  returns (I: Interface)
  requires Gr(Ix) &*& Gr(Iy)
  ensures Gr(Ix) &*& Gr(Iy) &*& intComp(Ix, Iy) == I &*& I != intUndef

lemma lemma_dirty_Gr_comp(Ix: Interface, Iy: Interface, I: Interface)
  returns (I1: Interface)
  requires [Gr(Ix) &*& Gr(Iy)](I)
  ensures [Gr(I1)](I) &*& intComp(Ix, Iy) == I1

lemma lemma_comp(Ix: Interface, Ix1: Interface, Iy: Interface, Iy1: Interface)
  returns (I: Interface)
  requires [Gr(Ix1)](Ix) &*& [Gr(Iy1)](Iy) &*& intValid(intComp(Ix1, Iy1)) == true
  ensures [Gr(Ix1) &*& Gr(Iy1)](I) &*& intComp(Ix, Iy) == I &*& I != intUndef

lemma lemma_comp_sing_int(x: Node, Ix: Interface, I2: Interface)
  returns (I: Interface)
  requires [acc(x)](Ix) &*& Gr(I2)
  ensures [acc(x)](Ix) &*& Gr(I2) &*& intComp(Ix, I2) == I &*& I != intUndef

lemma lemma_decomp(x: Node, I: Interface)
  returns (I1: Interface, I2: Interface)
  requires Gr(I) &*& x in I.FP
  ensures N(x, I1) &*& Gr(I2) &*& intComp(I1, I2) == I


lemma lemma_step(I1: Interface, I2: Interface, I: Interface, x: Node, y: Node)
  requires intComp(I1, I2) == I && x in I1.FP && y in I1.FPo && I.FPo == {}
  ensures y in I2.FP


lemma lemma_conc(x: Node, I: Interface)
  requires I != intUndef
  requires N(x, I)
  ensures [gamma(x, I)](I)

procedure lemma_abs(x: Node, I: Interface, I1: Interface)
  requires I != intUndef && I1 != intUndef && intValid(I1)
  requires [gamma(x, I1)](I) &*& I1.FP == {x}
  ensures [N(x, I1)](I)


lemma lemma_add_in(I: Interface, n: Node, In: Interface, I1: Interface)
  requires I1 == intComp(I, In) && In.FP == {n} && In.inf[n] == domZero()
     ensures forall n1: Node :: I.inf[n1] == I1.inf[n1] @(matching n1 yields I.inf[n1]) @(matching n1 yields I1.inf[n1])

lemma lemma_int_leq_fold(I1: Interface, I2: Interface)
  requires I1.FP == I2.FP && I1.FPo == I2.FPo
  requires forall n in I1.FP :: I1.inf[n] == I2.inf[n]
  requires forall n in I1.FP, o in I1.FPo :: I1.inf[n] != domZero() ==> I1.fm[n][o] == I2.fm[n][o]
  ensures intLeq(I1, I2) == true

lemma lemma_int_leq_unfold(I1: Interface, I2: Interface)
  requires intLeq(I1, I2) == true
  ensures I1.FP == I2.FP && I1.FPo == I2.FPo
  ensures forall n in I1.FP :: I1.inf[n] == I2.inf[n]
    @(matching n yields I1.inf[n]) @(matching n yields I2.inf[n])
  ensures forall n in I1.FP, o in I1.FPo :: I1.inf[n] != domZero() ==> I1.fm[n][o] == I2.fm[n][o]

lemma lemma_repl(I: Interface, Ix: Interface, Iy: Interface, Ix1: Interface, I1: Interface)
  requires I == intComp(Ix, Iy) && I1 == intComp(Ix1, Iy) && intLeq(Ix, Ix1) == true
  ensures intLeq(I, I1) == true

lemma lemma_N_is_conj(x: Node, Ix: Interface)
  requires N(x, Ix)
  ensures N(x, Ix) && [gamma(x, Ix)](Ix)

lemma lemma_conj_is_N(x: Node, Ix: Interface)
  requires N(x, Ix) && [gamma(x, Ix)](Ix)
  ensures N(x, Ix)

lemma lemma_Gr_comp_uniq(I: Interface, I1: Interface, I2: Interface)
  requires Gr(I) && (Gr(I1) &*& Gr(I2))
  ensures Gr(I1) &*& Gr(I2) &*& I == intComp(I1, I2)

lemma lemma_Gr_uniq(I1: Interface, I2: Interface)
  requires Gr(I1) && (Gr(I2) &*& I2 == I2)  // Hack to force this to be spatial
  ensures Gr(I1) &*& I1 == I2

lemma lemma_add_singl(I: Interface, x: Node, Ix: Interface, I1: Interface)
  requires I1 == intComp(I, Ix) && Ix.FP == {x} && Ix.inf[x] == domZero()
     && Ix.FPo == {}
  ensures I1.FPo == I.FPo
  ensures forall n: Node :: n in I.FP && I1.inf[n] == I.inf[n]
                    || n !in I.FP && I1.inf[n] == domZero()
    @(matching I.inf[n] yields I1.inf[n]) @(matching I1.inf[n] yields I.inf[n])

lemma lemma_disj(I1: Interface, I2: Interface,
                 x: Node, Ix: Interface, I3: Interface)
  returns (I4: Interface)
  requires (Gr(I1) &*& Gr(I2)) && (N(x, Ix) &*& Gr(I3)) &*& ndLeq(Ix.na, I1.na) == false
  ensures Gr(I1) &*& N(x, Ix) &*& Gr(I4)
    &*& I2 == intComp(Ix, I4) &*& I3 == intComp(I1, I4)


procedure sync(I1: Interface, I2: Interface)
  returns ()
  requires [Gr(I2)](I1) &*& intLeq(I1, I2) == true &*& intValid(I2) == true
  ensures Gr(I2)

procedure newNode()
  returns (x: Node, Ix: Interface)
  requires emp
  ensures [acc(x)](Ix)
  ensures intValid(Ix) && Ix.FP == {x} && Ix.inf[x] == domZero() && Ix.FPo == {}
