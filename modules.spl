signature PartialOrder {
  type T;

  predicate lt(x: T, y: T)
  
  axiom forall a: T :: !lt(a, a);
  axiom forall a: T, b: T :: !lt(a, b) || !lt(b, a);
  axiom forall a: T, b: T :: lt(a, b) || lt(b, a) || a == b;
  axiom forall a: T, b: T, c: T :: lt(a, b) && lt(b, c) ==> lt(a, c);
}

module IntOrder: PartialOrder {
  type T = Int;

  predicate lt(x: T, y: T) {
    x < y
  }
}

module SortedList(PO: PartialOrder) {
  type Data = PO.T;

  predicate lseg(x: Node, y: Node) {
    acc({ z: Node :: Btwn(next, x, z, y) && z != y}) &*& Reach(next, x, y)
  }

  predicate lseg_strictly_increasing(x: Node, FP: Set<Node>)
    requires acc(FP)
  {
    forall y: Node, z: Node :: y in FP && z in FP && Btwn(next,x,y,z) ==> PO.lt(y.data, z.data) || y == z
  }

  function data_witness(v: Data, FP: Set<Node>) returns (res: Node)
    requires acc(FP)
    ensures forall x in FP :: x == data_witness(x.data, FP)

  function content(FP: Set<Node>)
    returns (C: Set<Data>)
    requires acc(FP)
    ensures forall x in FP :: x.data in C
    ensures forall v in C :: data_witness(v, FP) in FP
    ensures forall v: Data :: v !in C ==> data_witness(v, FP) == null
    ensures forall v in C :: v == data_witness(v, FP).data @(matching v yields data_witness(v, FP).data)


  predicate list_set(x: Node, C: Set<Data>) {
    exists X: Set<Node> :: lseg(x, null) && acc(X) &*&
      lseg_strictly_increasing(x, X) &&
      C == content(X)
  }

  procedure append(val: Data, x: Node, implicit ghost C: Set<Data>) 
    returns (res: Node)
    requires list_set(x, C)
    requires forall v in C :: PO.lt(val, v)
    ensures list_set(res, C ++ {val})
  {
    res := new Node;
    res.next := x;
    res.data := val;
  }

  procedure insert(lst: Node, val: Data, implicit ghost C: Set<Data>)
    returns (res: Node)
    requires list_set(lst, C)
    ensures list_set(res, C ++ Set(val))  
  {
    var curr: Node;
    curr := lst;
    var prev: Node;
    prev := null;
  
    while (curr != null && lt(curr.data, val))
      invariant (prev == null && curr == lst || PO.lt(prev.data, val) &*& prev.next |-> curr) -** 
        list_set(lst, C)
    {
      prev := curr;
      curr := curr.next;
    }
  
    if (curr != null && curr.data == val) {
      return lst;
    }
  
    var n: Node;
    n := append(val, curr);
  
    if (prev == null) {
      return n;
    } else {
      prev.next := n;
      return lst;
    }
  }

  procedure empty()
    returns (res: Node)
    ensures list_set(res, {})
  {
    return null;
  }
}

module SortedIntList = SortedList(IntOrder);

open SortedIntList;

procedure main() {
  var l = empty();
  l := insert(l, 2);
  //...
}
