type K;

struct Node {
  var next: Node;
  var len: Int;
  var keys: Array<K>;
  var ptrs: Array<Node>;
}

define hrepSpatial(x) {
  acc(x) &*& acc(x.keys) &*& acc(x.ptrs)
}

datatype InrFn = inrfnC(inrfn: Map<Node, Set<K>>, inrdom: Set<Node>) | inrfnUndef;
  
datatype NodeDom = nd(contents: Set<K>, inr: InrFn);

datatype FlowDom = fd(ks: Map<K, Int>, ir: Map<K, Int>)

datatype Interface = int(na: NodeDom)

function inflow(x: Node) returns (i: Map<Node, FlowDom>)

function nodeabs(x: Node, inff: Map<Node, FlowDom>, C: Set<K>) returns (a: NodeDom)
{
  nd(C, inrfnC({n: Node :: n != x ? {} : {k: K :: inff[x].ks[k] >= 1 || inff[x].ir[k] >= 1}}, {x}))
}

function int_ind(x: Node, i: Int) returns (I: Interface)
{
  int(nodeabs(x, inflow(x), {}))
}

procedure foo(x: Node, I: Interface)
  requires hrepSpatial(x)
  ensures hrepSpatial(x)
{
  I := int_ind(x, x.len);
  pure assert I.na.contents == {};
}
